
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000010a  00800100  0000167a  0000170e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000167a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000645  0080020a  0080020a  00001818  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001818  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001f4  00000000  00000000  000020a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00002294  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000348  00000000  00000000  000022c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003e29  00000000  00000000  0000260b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000e6d  00000000  00000000  00006434  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000028fd  00000000  00000000  000072a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000948  00000000  00000000  00009ba0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000011a3  00000000  00000000  0000a4e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002c08  00000000  00000000  0000b68b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000388  00000000  00000000  0000e293  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4b c0       	rjmp	.+150    	; 0xc8 <__bad_interrupt>
      32:	00 00       	nop
      34:	a0 c7       	rjmp	.+3904   	; 0xf76 <__vector_13>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	3f c0       	rjmp	.+126    	; 0xc8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	27 c0       	rjmp	.+78     	; 0xc8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e4       	ldi	r29, 0x40	; 64
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ea e7       	ldi	r30, 0x7A	; 122
      a0:	f6 e1       	ldi	r31, 0x16	; 22
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	aa 30       	cpi	r26, 0x0A	; 10
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	28 e0       	ldi	r18, 0x08	; 8
      b4:	aa e0       	ldi	r26, 0x0A	; 10
      b6:	b2 e0       	ldi	r27, 0x02	; 2
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	af 34       	cpi	r26, 0x4F	; 79
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	c9 d5       	rcall	.+2962   	; 0xc56 <main>
      c4:	0c 94 3b 0b 	jmp	0x1676	; 0x1676 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      d0:	0e 94 19 09 	call	0x1232	; 0x1232 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      d4:	40 91 0a 02 	lds	r20, 0x020A
      d8:	50 91 0b 02 	lds	r21, 0x020B
      dc:	9e 01       	movw	r18, r28
      de:	24 0f       	add	r18, r20
      e0:	35 1f       	adc	r19, r21
      e2:	2c 3d       	cpi	r18, 0xDC	; 220
      e4:	85 e0       	ldi	r24, 0x05	; 5
      e6:	38 07       	cpc	r19, r24
      e8:	58 f4       	brcc	.+22     	; 0x100 <pvPortMalloc+0x36>
      ea:	42 17       	cp	r20, r18
      ec:	53 07       	cpc	r21, r19
      ee:	58 f4       	brcc	.+22     	; 0x106 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      f0:	ea 01       	movw	r28, r20
      f2:	c4 5f       	subi	r28, 0xF4	; 244
      f4:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
      f6:	30 93 0b 02 	sts	0x020B, r19
      fa:	20 93 0a 02 	sts	0x020A, r18
      fe:	05 c0       	rjmp	.+10     	; 0x10a <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     100:	c0 e0       	ldi	r28, 0x00	; 0
     102:	d0 e0       	ldi	r29, 0x00	; 0
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x40>
     106:	c0 e0       	ldi	r28, 0x00	; 0
     108:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     10a:	0e 94 e3 09 	call	0x13c6	; 0x13c6 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     10e:	8c 2f       	mov	r24, r28
     110:	9d 2f       	mov	r25, r29
     112:	df 91       	pop	r29
     114:	cf 91       	pop	r28
     116:	08 95       	ret

00000118 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     118:	08 95       	ret

0000011a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     11a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     11c:	03 96       	adiw	r24, 0x03	; 3
     11e:	92 83       	std	Z+2, r25	; 0x02
     120:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     122:	2f ef       	ldi	r18, 0xFF	; 255
     124:	3f ef       	ldi	r19, 0xFF	; 255
     126:	34 83       	std	Z+4, r19	; 0x04
     128:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     12a:	96 83       	std	Z+6, r25	; 0x06
     12c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     12e:	90 87       	std	Z+8, r25	; 0x08
     130:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     132:	10 82       	st	Z, r1
     134:	08 95       	ret

00000136 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     136:	fc 01       	movw	r30, r24
     138:	11 86       	std	Z+9, r1	; 0x09
     13a:	10 86       	std	Z+8, r1	; 0x08
     13c:	08 95       	ret

0000013e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     13e:	cf 93       	push	r28
     140:	df 93       	push	r29
     142:	fc 01       	movw	r30, r24
     144:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     146:	21 81       	ldd	r18, Z+1	; 0x01
     148:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     14a:	e9 01       	movw	r28, r18
     14c:	8a 81       	ldd	r24, Y+2	; 0x02
     14e:	9b 81       	ldd	r25, Y+3	; 0x03
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     158:	81 81       	ldd	r24, Z+1	; 0x01
     15a:	92 81       	ldd	r25, Z+2	; 0x02
     15c:	15 96       	adiw	r26, 0x05	; 5
     15e:	9c 93       	st	X, r25
     160:	8e 93       	st	-X, r24
     162:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     164:	8a 81       	ldd	r24, Y+2	; 0x02
     166:	9b 81       	ldd	r25, Y+3	; 0x03
     168:	ec 01       	movw	r28, r24
     16a:	7d 83       	std	Y+5, r23	; 0x05
     16c:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     16e:	e9 01       	movw	r28, r18
     170:	7b 83       	std	Y+3, r23	; 0x03
     172:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     174:	72 83       	std	Z+2, r23	; 0x02
     176:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     178:	19 96       	adiw	r26, 0x09	; 9
     17a:	fc 93       	st	X, r31
     17c:	ee 93       	st	-X, r30
     17e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     180:	80 81       	ld	r24, Z
     182:	8f 5f       	subi	r24, 0xFF	; 255
     184:	80 83       	st	Z, r24
}
     186:	df 91       	pop	r29
     188:	cf 91       	pop	r28
     18a:	08 95       	ret

0000018c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
     190:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     192:	48 81       	ld	r20, Y
     194:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     196:	4f 3f       	cpi	r20, 0xFF	; 255
     198:	2f ef       	ldi	r18, 0xFF	; 255
     19a:	52 07       	cpc	r21, r18
     19c:	31 f4       	brne	.+12     	; 0x1aa <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     19e:	dc 01       	movw	r26, r24
     1a0:	17 96       	adiw	r26, 0x07	; 7
     1a2:	ed 91       	ld	r30, X+
     1a4:	fc 91       	ld	r31, X
     1a6:	18 97       	sbiw	r26, 0x08	; 8
     1a8:	17 c0       	rjmp	.+46     	; 0x1d8 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1aa:	fc 01       	movw	r30, r24
     1ac:	33 96       	adiw	r30, 0x03	; 3
     1ae:	dc 01       	movw	r26, r24
     1b0:	15 96       	adiw	r26, 0x05	; 5
     1b2:	2d 91       	ld	r18, X+
     1b4:	3c 91       	ld	r19, X
     1b6:	16 97       	sbiw	r26, 0x06	; 6
     1b8:	d9 01       	movw	r26, r18
     1ba:	2d 91       	ld	r18, X+
     1bc:	3c 91       	ld	r19, X
     1be:	42 17       	cp	r20, r18
     1c0:	53 07       	cpc	r21, r19
     1c2:	50 f0       	brcs	.+20     	; 0x1d8 <vListInsert+0x4c>
     1c4:	02 80       	ldd	r0, Z+2	; 0x02
     1c6:	f3 81       	ldd	r31, Z+3	; 0x03
     1c8:	e0 2d       	mov	r30, r0
     1ca:	a2 81       	ldd	r26, Z+2	; 0x02
     1cc:	b3 81       	ldd	r27, Z+3	; 0x03
     1ce:	2d 91       	ld	r18, X+
     1d0:	3c 91       	ld	r19, X
     1d2:	42 17       	cp	r20, r18
     1d4:	53 07       	cpc	r21, r19
     1d6:	b0 f7       	brcc	.-20     	; 0x1c4 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1d8:	a2 81       	ldd	r26, Z+2	; 0x02
     1da:	b3 81       	ldd	r27, Z+3	; 0x03
     1dc:	bb 83       	std	Y+3, r27	; 0x03
     1de:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     1e0:	15 96       	adiw	r26, 0x05	; 5
     1e2:	dc 93       	st	X, r29
     1e4:	ce 93       	st	-X, r28
     1e6:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     1e8:	fd 83       	std	Y+5, r31	; 0x05
     1ea:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     1ec:	d3 83       	std	Z+3, r29	; 0x03
     1ee:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1f0:	99 87       	std	Y+9, r25	; 0x09
     1f2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1f4:	fc 01       	movw	r30, r24
     1f6:	20 81       	ld	r18, Z
     1f8:	2f 5f       	subi	r18, 0xFF	; 255
     1fa:	20 83       	st	Z, r18
}
     1fc:	df 91       	pop	r29
     1fe:	cf 91       	pop	r28
     200:	08 95       	ret

00000202 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     202:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     204:	a2 81       	ldd	r26, Z+2	; 0x02
     206:	b3 81       	ldd	r27, Z+3	; 0x03
     208:	84 81       	ldd	r24, Z+4	; 0x04
     20a:	95 81       	ldd	r25, Z+5	; 0x05
     20c:	15 96       	adiw	r26, 0x05	; 5
     20e:	9c 93       	st	X, r25
     210:	8e 93       	st	-X, r24
     212:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     214:	a4 81       	ldd	r26, Z+4	; 0x04
     216:	b5 81       	ldd	r27, Z+5	; 0x05
     218:	82 81       	ldd	r24, Z+2	; 0x02
     21a:	93 81       	ldd	r25, Z+3	; 0x03
     21c:	13 96       	adiw	r26, 0x03	; 3
     21e:	9c 93       	st	X, r25
     220:	8e 93       	st	-X, r24
     222:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     224:	a0 85       	ldd	r26, Z+8	; 0x08
     226:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     228:	11 96       	adiw	r26, 0x01	; 1
     22a:	8d 91       	ld	r24, X+
     22c:	9c 91       	ld	r25, X
     22e:	12 97       	sbiw	r26, 0x02	; 2
     230:	8e 17       	cp	r24, r30
     232:	9f 07       	cpc	r25, r31
     234:	31 f4       	brne	.+12     	; 0x242 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     236:	84 81       	ldd	r24, Z+4	; 0x04
     238:	95 81       	ldd	r25, Z+5	; 0x05
     23a:	12 96       	adiw	r26, 0x02	; 2
     23c:	9c 93       	st	X, r25
     23e:	8e 93       	st	-X, r24
     240:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     242:	11 86       	std	Z+9, r1	; 0x09
     244:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     246:	8c 91       	ld	r24, X
     248:	81 50       	subi	r24, 0x01	; 1
     24a:	8c 93       	st	X, r24
     24c:	08 95       	ret

0000024e <SetBit>:
//Functionality - Sets bit on a PORTx
//Parameter: Takes in a uChar for a PORTx, the pin number and the binary value 
//Returns: The new value of the PORTx
unsigned char SetBit(unsigned char pin, unsigned char number, unsigned char bin_value) 
{
	return (bin_value ? pin | (0x01 << number) : pin & ~(0x01 << number));
     24e:	44 23       	and	r20, r20
     250:	51 f0       	breq	.+20     	; 0x266 <SetBit+0x18>
     252:	41 e0       	ldi	r20, 0x01	; 1
     254:	50 e0       	ldi	r21, 0x00	; 0
     256:	9a 01       	movw	r18, r20
     258:	02 c0       	rjmp	.+4      	; 0x25e <SetBit+0x10>
     25a:	22 0f       	add	r18, r18
     25c:	33 1f       	adc	r19, r19
     25e:	6a 95       	dec	r22
     260:	e2 f7       	brpl	.-8      	; 0x25a <SetBit+0xc>
     262:	82 2b       	or	r24, r18
     264:	08 95       	ret
     266:	21 e0       	ldi	r18, 0x01	; 1
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	a9 01       	movw	r20, r18
     26c:	02 c0       	rjmp	.+4      	; 0x272 <SetBit+0x24>
     26e:	44 0f       	add	r20, r20
     270:	55 1f       	adc	r21, r21
     272:	6a 95       	dec	r22
     274:	e2 f7       	brpl	.-8      	; 0x26e <SetBit+0x20>
     276:	ba 01       	movw	r22, r20
     278:	60 95       	com	r22
     27a:	86 23       	and	r24, r22
}
     27c:	08 95       	ret

0000027e <GetBit>:
//Functionality - Gets bit from a PINx
//Parameter: Takes in a uChar for a PINx and the pin number
//Returns: The value of the PINx
unsigned char GetBit(unsigned char port, unsigned char number) 
{
	return ( port & (0x01 << number) );
     27e:	21 e0       	ldi	r18, 0x01	; 1
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	a9 01       	movw	r20, r18
     284:	02 c0       	rjmp	.+4      	; 0x28a <GetBit+0xc>
     286:	44 0f       	add	r20, r20
     288:	55 1f       	adc	r21, r21
     28a:	6a 95       	dec	r22
     28c:	e2 f7       	brpl	.-8      	; 0x286 <GetBit+0x8>
}
     28e:	84 23       	and	r24, r20
     290:	08 95       	ret

00000292 <GetKeypadKey>:
//Parameter: None
//Returns: A keypad button press else '\0'
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = SetBit(0xFF,COL1,0); // Set Px4 to 0; others 1
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	64 e0       	ldi	r22, 0x04	; 4
     296:	8f ef       	ldi	r24, 0xFF	; 255
     298:	da df       	rcall	.-76     	; 0x24e <SetBit>
     29a:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     29c:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     29e:	86 b1       	in	r24, 0x06	; 6
     2a0:	60 e0       	ldi	r22, 0x00	; 0
     2a2:	80 95       	com	r24
     2a4:	ec df       	rcall	.-40     	; 0x27e <GetBit>
     2a6:	81 11       	cpse	r24, r1
     2a8:	6e c0       	rjmp	.+220    	; 0x386 <GetKeypadKey+0xf4>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     2aa:	86 b1       	in	r24, 0x06	; 6
     2ac:	61 e0       	ldi	r22, 0x01	; 1
     2ae:	80 95       	com	r24
     2b0:	e6 df       	rcall	.-52     	; 0x27e <GetBit>
     2b2:	81 11       	cpse	r24, r1
     2b4:	6a c0       	rjmp	.+212    	; 0x38a <GetKeypadKey+0xf8>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     2b6:	86 b1       	in	r24, 0x06	; 6
     2b8:	62 e0       	ldi	r22, 0x02	; 2
     2ba:	80 95       	com	r24
     2bc:	e0 df       	rcall	.-64     	; 0x27e <GetBit>
     2be:	81 11       	cpse	r24, r1
     2c0:	66 c0       	rjmp	.+204    	; 0x38e <GetKeypadKey+0xfc>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     2c2:	86 b1       	in	r24, 0x06	; 6
     2c4:	63 e0       	ldi	r22, 0x03	; 3
     2c6:	80 95       	com	r24
     2c8:	da df       	rcall	.-76     	; 0x27e <GetBit>
     2ca:	81 11       	cpse	r24, r1
     2cc:	62 c0       	rjmp	.+196    	; 0x392 <GetKeypadKey+0x100>

	// Check keys in col 2
	KEYPADPORT = SetBit(0xFF,COL2,0); // Set Px5 to 0; others 1
     2ce:	40 e0       	ldi	r20, 0x00	; 0
     2d0:	65 e0       	ldi	r22, 0x05	; 5
     2d2:	8f ef       	ldi	r24, 0xFF	; 255
     2d4:	bc df       	rcall	.-136    	; 0x24e <SetBit>
     2d6:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     2d8:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     2da:	86 b1       	in	r24, 0x06	; 6
     2dc:	60 e0       	ldi	r22, 0x00	; 0
     2de:	80 95       	com	r24
     2e0:	ce df       	rcall	.-100    	; 0x27e <GetBit>
     2e2:	81 11       	cpse	r24, r1
     2e4:	58 c0       	rjmp	.+176    	; 0x396 <GetKeypadKey+0x104>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     2e6:	86 b1       	in	r24, 0x06	; 6
     2e8:	61 e0       	ldi	r22, 0x01	; 1
     2ea:	80 95       	com	r24
     2ec:	c8 df       	rcall	.-112    	; 0x27e <GetBit>
     2ee:	81 11       	cpse	r24, r1
     2f0:	54 c0       	rjmp	.+168    	; 0x39a <GetKeypadKey+0x108>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     2f2:	86 b1       	in	r24, 0x06	; 6
     2f4:	62 e0       	ldi	r22, 0x02	; 2
     2f6:	80 95       	com	r24
     2f8:	c2 df       	rcall	.-124    	; 0x27e <GetBit>
     2fa:	81 11       	cpse	r24, r1
     2fc:	50 c0       	rjmp	.+160    	; 0x39e <GetKeypadKey+0x10c>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     2fe:	86 b1       	in	r24, 0x06	; 6
     300:	63 e0       	ldi	r22, 0x03	; 3
     302:	80 95       	com	r24
     304:	bc df       	rcall	.-136    	; 0x27e <GetBit>
     306:	81 11       	cpse	r24, r1
     308:	4c c0       	rjmp	.+152    	; 0x3a2 <GetKeypadKey+0x110>

	// Check keys in col 3
	KEYPADPORT = SetBit(0xFF,COL3,0); // Set Px6 to 0; others 1
     30a:	40 e0       	ldi	r20, 0x00	; 0
     30c:	66 e0       	ldi	r22, 0x06	; 6
     30e:	8f ef       	ldi	r24, 0xFF	; 255
     310:	9e df       	rcall	.-196    	; 0x24e <SetBit>
     312:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     314:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     316:	86 b1       	in	r24, 0x06	; 6
     318:	60 e0       	ldi	r22, 0x00	; 0
     31a:	80 95       	com	r24
     31c:	b0 df       	rcall	.-160    	; 0x27e <GetBit>
     31e:	81 11       	cpse	r24, r1
     320:	42 c0       	rjmp	.+132    	; 0x3a6 <GetKeypadKey+0x114>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     322:	86 b1       	in	r24, 0x06	; 6
     324:	61 e0       	ldi	r22, 0x01	; 1
     326:	80 95       	com	r24
     328:	aa df       	rcall	.-172    	; 0x27e <GetBit>
     32a:	81 11       	cpse	r24, r1
     32c:	3e c0       	rjmp	.+124    	; 0x3aa <GetKeypadKey+0x118>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     32e:	86 b1       	in	r24, 0x06	; 6
     330:	62 e0       	ldi	r22, 0x02	; 2
     332:	80 95       	com	r24
     334:	a4 df       	rcall	.-184    	; 0x27e <GetBit>
     336:	81 11       	cpse	r24, r1
     338:	3a c0       	rjmp	.+116    	; 0x3ae <GetKeypadKey+0x11c>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     33a:	86 b1       	in	r24, 0x06	; 6
     33c:	63 e0       	ldi	r22, 0x03	; 3
     33e:	80 95       	com	r24
     340:	9e df       	rcall	.-196    	; 0x27e <GetBit>
     342:	81 11       	cpse	r24, r1
     344:	36 c0       	rjmp	.+108    	; 0x3b2 <GetKeypadKey+0x120>

	// Check keys in col 4
	KEYPADPORT = SetBit(0xFF,COL4,0); // Set Px7 to 0; others 1
     346:	40 e0       	ldi	r20, 0x00	; 0
     348:	67 e0       	ldi	r22, 0x07	; 7
     34a:	8f ef       	ldi	r24, 0xFF	; 255
     34c:	80 df       	rcall	.-256    	; 0x24e <SetBit>
     34e:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     350:	00 00       	nop
	if (GetBit(~KEYPADPIN,ROW1) ) { return 'A'; }
     352:	86 b1       	in	r24, 0x06	; 6
     354:	60 e0       	ldi	r22, 0x00	; 0
     356:	80 95       	com	r24
     358:	92 df       	rcall	.-220    	; 0x27e <GetBit>
     35a:	81 11       	cpse	r24, r1
     35c:	2c c0       	rjmp	.+88     	; 0x3b6 <GetKeypadKey+0x124>
	if (GetBit(~KEYPADPIN,ROW2) ) { return 'B'; }
     35e:	86 b1       	in	r24, 0x06	; 6
     360:	61 e0       	ldi	r22, 0x01	; 1
     362:	80 95       	com	r24
     364:	8c df       	rcall	.-232    	; 0x27e <GetBit>
     366:	81 11       	cpse	r24, r1
     368:	28 c0       	rjmp	.+80     	; 0x3ba <GetKeypadKey+0x128>
	if (GetBit(~KEYPADPIN,ROW3) ) { return 'C'; }
     36a:	86 b1       	in	r24, 0x06	; 6
     36c:	62 e0       	ldi	r22, 0x02	; 2
     36e:	80 95       	com	r24
     370:	86 df       	rcall	.-244    	; 0x27e <GetBit>
     372:	81 11       	cpse	r24, r1
     374:	24 c0       	rjmp	.+72     	; 0x3be <GetKeypadKey+0x12c>
	if (GetBit(~KEYPADPIN,ROW4) ) { return 'D'; }
     376:	86 b1       	in	r24, 0x06	; 6
     378:	63 e0       	ldi	r22, 0x03	; 3
     37a:	80 95       	com	r24
     37c:	80 df       	rcall	.-256    	; 0x27e <GetBit>
     37e:	88 23       	and	r24, r24
     380:	01 f1       	breq	.+64     	; 0x3c2 <GetKeypadKey+0x130>
     382:	84 e4       	ldi	r24, 0x44	; 68
     384:	08 95       	ret
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = SetBit(0xFF,COL1,0); // Set Px4 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     386:	81 e3       	ldi	r24, 0x31	; 49
     388:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     38a:	84 e3       	ldi	r24, 0x34	; 52
     38c:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     38e:	87 e3       	ldi	r24, 0x37	; 55
     390:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     392:	8a e2       	ldi	r24, 0x2A	; 42
     394:	08 95       	ret

	// Check keys in col 2
	KEYPADPORT = SetBit(0xFF,COL2,0); // Set Px5 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     396:	82 e3       	ldi	r24, 0x32	; 50
     398:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     39a:	85 e3       	ldi	r24, 0x35	; 53
     39c:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     39e:	88 e3       	ldi	r24, 0x38	; 56
     3a0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     3a2:	80 e3       	ldi	r24, 0x30	; 48
     3a4:	08 95       	ret

	// Check keys in col 3
	KEYPADPORT = SetBit(0xFF,COL3,0); // Set Px6 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     3a6:	83 e3       	ldi	r24, 0x33	; 51
     3a8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     3aa:	86 e3       	ldi	r24, 0x36	; 54
     3ac:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     3ae:	89 e3       	ldi	r24, 0x39	; 57
     3b0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     3b2:	83 e2       	ldi	r24, 0x23	; 35
     3b4:	08 95       	ret

	// Check keys in col 4
	KEYPADPORT = SetBit(0xFF,COL4,0); // Set Px7 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if (GetBit(~KEYPADPIN,ROW1) ) { return 'A'; }
     3b6:	81 e4       	ldi	r24, 0x41	; 65
     3b8:	08 95       	ret
	if (GetBit(~KEYPADPIN,ROW2) ) { return 'B'; }
     3ba:	82 e4       	ldi	r24, 0x42	; 66
     3bc:	08 95       	ret
	if (GetBit(~KEYPADPIN,ROW3) ) { return 'C'; }
     3be:	83 e4       	ldi	r24, 0x43	; 67
     3c0:	08 95       	ret
	if (GetBit(~KEYPADPIN,ROW4) ) { return 'D'; }
	
	return '\0';
     3c2:	80 e0       	ldi	r24, 0x00	; 0
}
     3c4:	08 95       	ret

000003c6 <delay_ms>:

/*-------------------------------------------------------------------------*/

void delay_ms(int miliSec) { //for 8 Mhz crystal
	int i,j;
	for(i=0;i<miliSec;i++) {
     3c6:	18 16       	cp	r1, r24
     3c8:	19 06       	cpc	r1, r25
     3ca:	5c f0       	brlt	.+22     	; 0x3e2 <delay_ms+0x1c>
     3cc:	08 95       	ret
		for(j=0;j<775;j++) {
			asm("nop");
     3ce:	00 00       	nop
     3d0:	21 50       	subi	r18, 0x01	; 1
     3d2:	31 09       	sbc	r19, r1
/*-------------------------------------------------------------------------*/

void delay_ms(int miliSec) { //for 8 Mhz crystal
	int i,j;
	for(i=0;i<miliSec;i++) {
		for(j=0;j<775;j++) {
     3d4:	e1 f7       	brne	.-8      	; 0x3ce <delay_ms+0x8>

/*-------------------------------------------------------------------------*/

void delay_ms(int miliSec) { //for 8 Mhz crystal
	int i,j;
	for(i=0;i<miliSec;i++) {
     3d6:	4f 5f       	subi	r20, 0xFF	; 255
     3d8:	5f 4f       	sbci	r21, 0xFF	; 255
     3da:	48 17       	cp	r20, r24
     3dc:	59 07       	cpc	r21, r25
     3de:	29 f4       	brne	.+10     	; 0x3ea <delay_ms+0x24>
     3e0:	08 95       	ret
     3e2:	40 e0       	ldi	r20, 0x00	; 0
     3e4:	50 e0       	ldi	r21, 0x00	; 0
#define RS 0				// pin number of uC connected to pin 4 of LCD disp.
#define E 1					// pin number of uC connected to pin 6 of LCD disp.

/*-------------------------------------------------------------------------*/

void delay_ms(int miliSec) { //for 8 Mhz crystal
     3e6:	67 e0       	ldi	r22, 0x07	; 7
     3e8:	73 e0       	ldi	r23, 0x03	; 3
     3ea:	9b 01       	movw	r18, r22
     3ec:	f0 cf       	rjmp	.-32     	; 0x3ce <delay_ms+0x8>

000003ee <LCD_WriteCommand>:
}

/*-------------------------------------------------------------------------*/

void LCD_WriteCommand (unsigned char Command) {
	CLR_BIT(CONTROL_BUS,RS);
     3ee:	10 98       	cbi	0x02, 0	; 2
	DATA_BUS = Command;
     3f0:	8b b9       	out	0x0b, r24	; 11
	SET_BIT(CONTROL_BUS,E);
     3f2:	11 9a       	sbi	0x02, 1	; 2
	asm("nop");
     3f4:	00 00       	nop
	CLR_BIT(CONTROL_BUS,E);
     3f6:	11 98       	cbi	0x02, 1	; 2
	delay_ms(2); // ClearScreen requires 1.52ms to execute
     3f8:	82 e0       	ldi	r24, 0x02	; 2
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	e4 cf       	rjmp	.-56     	; 0x3c6 <delay_ms>

000003fe <LCD_ClearScreen>:
}

void LCD_ClearScreen(void) {
	LCD_WriteCommand(0x01);
     3fe:	81 e0       	ldi	r24, 0x01	; 1
     400:	f6 cf       	rjmp	.-20     	; 0x3ee <LCD_WriteCommand>

00000402 <LCD_init>:
}

void LCD_init(void) {
	delay_ms(100); //wait for 100 ms for LCD to power up
     402:	84 e6       	ldi	r24, 0x64	; 100
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	df df       	rcall	.-66     	; 0x3c6 <delay_ms>
	LCD_WriteCommand(0x38);
     408:	88 e3       	ldi	r24, 0x38	; 56
     40a:	f1 df       	rcall	.-30     	; 0x3ee <LCD_WriteCommand>
	LCD_WriteCommand(0x06);
     40c:	86 e0       	ldi	r24, 0x06	; 6
     40e:	ef df       	rcall	.-34     	; 0x3ee <LCD_WriteCommand>
	LCD_WriteCommand(0x0f);
     410:	8f e0       	ldi	r24, 0x0F	; 15
     412:	ed df       	rcall	.-38     	; 0x3ee <LCD_WriteCommand>
	LCD_WriteCommand(0x01);
     414:	81 e0       	ldi	r24, 0x01	; 1
     416:	eb df       	rcall	.-42     	; 0x3ee <LCD_WriteCommand>
	delay_ms(10);						 
     418:	8a e0       	ldi	r24, 0x0A	; 10
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	d4 cf       	rjmp	.-88     	; 0x3c6 <delay_ms>

0000041e <LCD_WriteData>:
}

void LCD_WriteData(unsigned char Data) {
	SET_BIT(CONTROL_BUS,RS);
     41e:	10 9a       	sbi	0x02, 0	; 2
	DATA_BUS = Data;
     420:	8b b9       	out	0x0b, r24	; 11
	SET_BIT(CONTROL_BUS,E);
     422:	11 9a       	sbi	0x02, 1	; 2
	asm("nop");
     424:	00 00       	nop
	CLR_BIT(CONTROL_BUS,E);
     426:	11 98       	cbi	0x02, 1	; 2
	delay_ms(1);
     428:	81 e0       	ldi	r24, 0x01	; 1
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	cc cf       	rjmp	.-104    	; 0x3c6 <delay_ms>

0000042e <LCD_Cursor>:
}

void LCD_Cursor(unsigned char column) {
	if ( column < 17 ) { // 16x2 LCD: column < 17; 16x1 LCD: column < 9
     42e:	81 31       	cpi	r24, 0x11	; 17
     430:	10 f4       	brcc	.+4      	; 0x436 <LCD_Cursor+0x8>
		LCD_WriteCommand(0x80 + column - 1);
     432:	81 58       	subi	r24, 0x81	; 129
     434:	dc cf       	rjmp	.-72     	; 0x3ee <LCD_WriteCommand>
		} else { // 6x2 LCD: column - 9; 16x1 LCD: column - 1
		LCD_WriteCommand(0xB8 + column - 9);
     436:	81 55       	subi	r24, 0x51	; 81
     438:	da cf       	rjmp	.-76     	; 0x3ee <LCD_WriteCommand>

0000043a <LCD_DisplayString>:
	}
}

void LCD_DisplayString( unsigned char column, const unsigned char* string) {
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	18 2f       	mov	r17, r24
     442:	eb 01       	movw	r28, r22
	LCD_ClearScreen();
     444:	dc df       	rcall	.-72     	; 0x3fe <LCD_ClearScreen>
	unsigned char c = column;
	while(*string) {
     446:	98 81       	ld	r25, Y
     448:	99 23       	and	r25, r25
     44a:	51 f0       	breq	.+20     	; 0x460 <LCD_DisplayString+0x26>
	}
}

void LCD_DisplayString( unsigned char column, const unsigned char* string) {
	LCD_ClearScreen();
	unsigned char c = column;
     44c:	81 2f       	mov	r24, r17
	while(*string) {
		LCD_Cursor(c++);
     44e:	18 2f       	mov	r17, r24
     450:	1f 5f       	subi	r17, 0xFF	; 255
     452:	ed df       	rcall	.-38     	; 0x42e <LCD_Cursor>
		LCD_WriteData(*string++);
     454:	89 91       	ld	r24, Y+
     456:	e3 df       	rcall	.-58     	; 0x41e <LCD_WriteData>

void LCD_DisplayString( unsigned char column, const unsigned char* string) {
	LCD_ClearScreen();
	unsigned char c = column;
	while(*string) {
		LCD_Cursor(c++);
     458:	81 2f       	mov	r24, r17
}

void LCD_DisplayString( unsigned char column, const unsigned char* string) {
	LCD_ClearScreen();
	unsigned char c = column;
	while(*string) {
     45a:	98 81       	ld	r25, Y
     45c:	91 11       	cpse	r25, r1
     45e:	f7 cf       	rjmp	.-18     	; 0x44e <LCD_DisplayString+0x14>
		LCD_Cursor(c++);
		LCD_WriteData(*string++);
	}
}
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	1f 91       	pop	r17
     466:	08 95       	ret

00000468 <Key_Tick>:
enum keyState {INITK, set_a, set_b, set_c, set_d} key_state;

void Key_Tick()
{
// Transitions
	switch(key_state)
     468:	80 91 4e 08 	lds	r24, 0x084E
     46c:	82 30       	cpi	r24, 0x02	; 2
     46e:	69 f1       	breq	.+90     	; 0x4ca <Key_Tick+0x62>
     470:	28 f4       	brcc	.+10     	; 0x47c <Key_Tick+0x14>
     472:	88 23       	and	r24, r24
     474:	41 f0       	breq	.+16     	; 0x486 <Key_Tick+0x1e>
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	89 f5       	brne	.+98     	; 0x4dc <Key_Tick+0x74>
     47a:	24 c0       	rjmp	.+72     	; 0x4c4 <Key_Tick+0x5c>
     47c:	83 30       	cpi	r24, 0x03	; 3
     47e:	41 f1       	breq	.+80     	; 0x4d0 <Key_Tick+0x68>
     480:	84 30       	cpi	r24, 0x04	; 4
     482:	61 f5       	brne	.+88     	; 0x4dc <Key_Tick+0x74>
     484:	28 c0       	rjmp	.+80     	; 0x4d6 <Key_Tick+0x6e>
	{
		case INITK:
			if(GetKeypadKey() == 'A')
     486:	05 df       	rcall	.-502    	; 0x292 <GetKeypadKey>
     488:	81 34       	cpi	r24, 0x41	; 65
     48a:	21 f4       	brne	.+8      	; 0x494 <Key_Tick+0x2c>
				key_state = set_a;
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	80 93 4e 08 	sts	0x084E, r24
     492:	2f c0       	rjmp	.+94     	; 0x4f2 <Key_Tick+0x8a>
			else if(GetKeypadKey() == 'B')
     494:	fe de       	rcall	.-516    	; 0x292 <GetKeypadKey>
     496:	82 34       	cpi	r24, 0x42	; 66
     498:	21 f4       	brne	.+8      	; 0x4a2 <Key_Tick+0x3a>
				key_state = set_b;
     49a:	82 e0       	ldi	r24, 0x02	; 2
     49c:	80 93 4e 08 	sts	0x084E, r24
     4a0:	2c c0       	rjmp	.+88     	; 0x4fa <Key_Tick+0x92>
			else if(GetKeypadKey() == 'C')
     4a2:	f7 de       	rcall	.-530    	; 0x292 <GetKeypadKey>
     4a4:	83 34       	cpi	r24, 0x43	; 67
     4a6:	21 f4       	brne	.+8      	; 0x4b0 <Key_Tick+0x48>
				key_state = set_c;
     4a8:	83 e0       	ldi	r24, 0x03	; 3
     4aa:	80 93 4e 08 	sts	0x084E, r24
     4ae:	29 c0       	rjmp	.+82     	; 0x502 <Key_Tick+0x9a>
			else if(GetKeypadKey() == 'D')
     4b0:	f0 de       	rcall	.-544    	; 0x292 <GetKeypadKey>
     4b2:	84 34       	cpi	r24, 0x44	; 68
     4b4:	21 f4       	brne	.+8      	; 0x4be <Key_Tick+0x56>
				key_state = set_d;
     4b6:	84 e0       	ldi	r24, 0x04	; 4
     4b8:	80 93 4e 08 	sts	0x084E, r24
     4bc:	26 c0       	rjmp	.+76     	; 0x50a <Key_Tick+0xa2>
			else
				key_state = INITK;
     4be:	10 92 4e 08 	sts	0x084E, r1
     4c2:	08 95       	ret
			break;
		case set_a:
			key_state = INITK;
     4c4:	10 92 4e 08 	sts	0x084E, r1
			break;
     4c8:	08 95       	ret
		case set_b:
			key_state = INITK;
     4ca:	10 92 4e 08 	sts	0x084E, r1
			break;
     4ce:	08 95       	ret
		case set_c:
			key_state = INITK;
     4d0:	10 92 4e 08 	sts	0x084E, r1
			break;
     4d4:	08 95       	ret
		case set_d:
			key_state = INITK;
     4d6:	10 92 4e 08 	sts	0x084E, r1
			break;
     4da:	08 95       	ret
	}

// Actions
	switch(key_state)
     4dc:	82 30       	cpi	r24, 0x02	; 2
     4de:	69 f0       	breq	.+26     	; 0x4fa <Key_Tick+0x92>
     4e0:	18 f4       	brcc	.+6      	; 0x4e8 <Key_Tick+0x80>
     4e2:	81 30       	cpi	r24, 0x01	; 1
     4e4:	a9 f4       	brne	.+42     	; 0x510 <Key_Tick+0xa8>
     4e6:	05 c0       	rjmp	.+10     	; 0x4f2 <Key_Tick+0x8a>
     4e8:	83 30       	cpi	r24, 0x03	; 3
     4ea:	59 f0       	breq	.+22     	; 0x502 <Key_Tick+0x9a>
     4ec:	84 30       	cpi	r24, 0x04	; 4
     4ee:	81 f4       	brne	.+32     	; 0x510 <Key_Tick+0xa8>
     4f0:	0c c0       	rjmp	.+24     	; 0x50a <Key_Tick+0xa2>
	{
		case INITK:
			break;
		case set_a:
			choice = 'A';
     4f2:	81 e4       	ldi	r24, 0x41	; 65
     4f4:	80 93 48 08 	sts	0x0848, r24
			break;
     4f8:	08 95       	ret
		case set_b:
			choice = 'B';
     4fa:	82 e4       	ldi	r24, 0x42	; 66
     4fc:	80 93 48 08 	sts	0x0848, r24
			break;
     500:	08 95       	ret
		case set_c:
			choice = 'C';
     502:	83 e4       	ldi	r24, 0x43	; 67
     504:	80 93 48 08 	sts	0x0848, r24
			break;
     508:	08 95       	ret
		case set_d:
			choice = 'D';
     50a:	84 e4       	ldi	r24, 0x44	; 68
     50c:	80 93 48 08 	sts	0x0848, r24
     510:	08 95       	ret

00000512 <verify_code>:
}

enum LCD_states {LCDinit, door, ch_code, n_page, set_thermo} lcd_state;

bool verify_code()
{
     512:	df 92       	push	r13
     514:	ef 92       	push	r14
     516:	ff 92       	push	r15
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	cf 93       	push	r28
     51e:	df 93       	push	r29
     520:	00 d0       	rcall	.+0      	; 0x522 <verify_code+0x10>
     522:	00 d0       	rcall	.+0      	; 0x524 <verify_code+0x12>
     524:	00 d0       	rcall	.+0      	; 0x526 <verify_code+0x14>
     526:	cd b7       	in	r28, 0x3d	; 61
     528:	de b7       	in	r29, 0x3e	; 62
	bool first, sec, third, fourth, fifth = false;
	char temp = '\0';
	char temp_code[6] = {' ',' ',' ',' ',' ','\0'};
     52a:	86 e0       	ldi	r24, 0x06	; 6
     52c:	eb e1       	ldi	r30, 0x1B	; 27
     52e:	f1 e0       	ldi	r31, 0x01	; 1
     530:	de 01       	movw	r26, r28
     532:	11 96       	adiw	r26, 0x01	; 1
     534:	01 90       	ld	r0, Z+
     536:	0d 92       	st	X+, r0
     538:	8a 95       	dec	r24
     53a:	e1 f7       	brne	.-8      	; 0x534 <verify_code+0x22>
	LCD_DisplayString(1, enter_cur_code_string);
     53c:	60 91 09 01 	lds	r22, 0x0109
     540:	70 91 0a 01 	lds	r23, 0x010A
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	79 df       	rcall	.-270    	; 0x43a <LCD_DisplayString>
     548:	8e 01       	movw	r16, r28
     54a:	0f 5f       	subi	r16, 0xFF	; 255
     54c:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}

enum LCD_states {LCDinit, door, ch_code, n_page, set_thermo} lcd_state;

bool verify_code()
     54e:	7e 01       	movw	r14, r28
     550:	86 e0       	ldi	r24, 0x06	; 6
     552:	e8 0e       	add	r14, r24
     554:	f1 1c       	adc	r15, r1
	// Verifying current passcode
	for(int i = 0; i < 5; i++)
	{
		while(true)
		{
			temp = GetKeypadKey();
     556:	9d de       	rcall	.-710    	; 0x292 <GetKeypadKey>
     558:	d8 2e       	mov	r13, r24
			delay_ms(300);
     55a:	8c e2       	ldi	r24, 0x2C	; 44
     55c:	91 e0       	ldi	r25, 0x01	; 1
     55e:	33 df       	rcall	.-410    	; 0x3c6 <delay_ms>
			if(temp != '\0') break;
     560:	dd 20       	and	r13, r13
     562:	c9 f3       	breq	.-14     	; 0x556 <verify_code+0x44>
		}
		temp_code[i] = temp;
     564:	f8 01       	movw	r30, r16
     566:	d1 92       	st	Z+, r13
     568:	8f 01       	movw	r16, r30

		LCD_DisplayString(1, temp_code);
     56a:	be 01       	movw	r22, r28
     56c:	6f 5f       	subi	r22, 0xFF	; 255
     56e:	7f 4f       	sbci	r23, 0xFF	; 255
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	63 df       	rcall	.-314    	; 0x43a <LCD_DisplayString>
	bool first, sec, third, fourth, fifth = false;
	char temp = '\0';
	char temp_code[6] = {' ',' ',' ',' ',' ','\0'};
	LCD_DisplayString(1, enter_cur_code_string);
	// Verifying current passcode
	for(int i = 0; i < 5; i++)
     574:	0e 15       	cp	r16, r14
     576:	1f 05       	cpc	r17, r15
     578:	71 f7       	brne	.-36     	; 0x556 <verify_code+0x44>
		temp_code[i] = temp;

		LCD_DisplayString(1, temp_code);
		temp = '\0';
	}
	if(!(temp_code[0] == code[0] && temp_code[1] == code[1] && temp_code[2] == code[2] && 
     57a:	99 81       	ldd	r25, Y+1	; 0x01
     57c:	80 91 00 01 	lds	r24, 0x0100
     580:	98 13       	cpse	r25, r24
     582:	14 c0       	rjmp	.+40     	; 0x5ac <verify_code+0x9a>
     584:	9a 81       	ldd	r25, Y+2	; 0x02
     586:	80 91 01 01 	lds	r24, 0x0101
     58a:	98 13       	cpse	r25, r24
     58c:	0f c0       	rjmp	.+30     	; 0x5ac <verify_code+0x9a>
     58e:	9b 81       	ldd	r25, Y+3	; 0x03
     590:	80 91 02 01 	lds	r24, 0x0102
     594:	98 13       	cpse	r25, r24
     596:	0a c0       	rjmp	.+20     	; 0x5ac <verify_code+0x9a>
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	80 91 03 01 	lds	r24, 0x0103
     59e:	98 13       	cpse	r25, r24
     5a0:	05 c0       	rjmp	.+10     	; 0x5ac <verify_code+0x9a>
     5a2:	9d 81       	ldd	r25, Y+5	; 0x05
     5a4:	80 91 04 01 	lds	r24, 0x0104
     5a8:	98 17       	cp	r25, r24
     5aa:	41 f0       	breq	.+16     	; 0x5bc <verify_code+0xaa>
		temp_code[3] == code[3] && temp_code[4] == code[4]))
		{
			LCD_DisplayString(1, invalid_code_string);
     5ac:	60 91 05 01 	lds	r22, 0x0105
     5b0:	70 91 06 01 	lds	r23, 0x0106
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	41 df       	rcall	.-382    	; 0x43a <LCD_DisplayString>
			return false;
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	01 c0       	rjmp	.+2      	; 0x5be <verify_code+0xac>
		}
	
	return true;
     5bc:	81 e0       	ldi	r24, 0x01	; 1
}
     5be:	26 96       	adiw	r28, 0x06	; 6
     5c0:	0f b6       	in	r0, 0x3f	; 63
     5c2:	f8 94       	cli
     5c4:	de bf       	out	0x3e, r29	; 62
     5c6:	0f be       	out	0x3f, r0	; 63
     5c8:	cd bf       	out	0x3d, r28	; 61
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	1f 91       	pop	r17
     5d0:	0f 91       	pop	r16
     5d2:	ff 90       	pop	r15
     5d4:	ef 90       	pop	r14
     5d6:	df 90       	pop	r13
     5d8:	08 95       	ret

000005da <change_code>:

void change_code()
{
     5da:	bf 92       	push	r11
     5dc:	cf 92       	push	r12
     5de:	df 92       	push	r13
     5e0:	ef 92       	push	r14
     5e2:	ff 92       	push	r15
     5e4:	0f 93       	push	r16
     5e6:	1f 93       	push	r17
     5e8:	cf 93       	push	r28
     5ea:	df 93       	push	r29
     5ec:	00 d0       	rcall	.+0      	; 0x5ee <change_code+0x14>
     5ee:	00 d0       	rcall	.+0      	; 0x5f0 <change_code+0x16>
     5f0:	00 d0       	rcall	.+0      	; 0x5f2 <change_code+0x18>
     5f2:	cd b7       	in	r28, 0x3d	; 61
     5f4:	de b7       	in	r29, 0x3e	; 62
	char temp = '\0';
	char n_code[6] = {' ',' ',' ',' ',' ','\0'};	
     5f6:	86 e0       	ldi	r24, 0x06	; 6
     5f8:	eb e1       	ldi	r30, 0x1B	; 27
     5fa:	f1 e0       	ldi	r31, 0x01	; 1
     5fc:	de 01       	movw	r26, r28
     5fe:	11 96       	adiw	r26, 0x01	; 1
     600:	01 90       	ld	r0, Z+
     602:	0d 92       	st	X+, r0
     604:	8a 95       	dec	r24
     606:	e1 f7       	brne	.-8      	; 0x600 <change_code+0x26>
	LCD_DisplayString(1, enter_new_code_string);
     608:	60 91 07 01 	lds	r22, 0x0107
     60c:	70 91 08 01 	lds	r23, 0x0108
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	13 df       	rcall	.-474    	; 0x43a <LCD_DisplayString>
     614:	8e 01       	movw	r16, r28
     616:	0f 5f       	subi	r16, 0xFF	; 255
     618:	1f 4f       	sbci	r17, 0xFF	; 255
     61a:	0f 2e       	mov	r0, r31
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	ef 2e       	mov	r14, r31
     620:	f1 e0       	ldi	r31, 0x01	; 1
     622:	ff 2e       	mov	r15, r31
     624:	f0 2d       	mov	r31, r0
		}
	
	return true;
}

void change_code()
     626:	6e 01       	movw	r12, r28
     628:	86 e0       	ldi	r24, 0x06	; 6
     62a:	c8 0e       	add	r12, r24
     62c:	d1 1c       	adc	r13, r1
	LCD_DisplayString(1, enter_new_code_string);
	for(int i = 0; i < 5; i++)
	{
		while(true)
		{
			temp = GetKeypadKey();
     62e:	31 de       	rcall	.-926    	; 0x292 <GetKeypadKey>
     630:	b8 2e       	mov	r11, r24
			delay_ms(300);
     632:	8c e2       	ldi	r24, 0x2C	; 44
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	c7 de       	rcall	.-626    	; 0x3c6 <delay_ms>
			if(temp != '\0') break;
     638:	bb 20       	and	r11, r11
     63a:	c9 f3       	breq	.-14     	; 0x62e <change_code+0x54>
		}
		n_code[i] = temp;
     63c:	f8 01       	movw	r30, r16
     63e:	b1 92       	st	Z+, r11
     640:	8f 01       	movw	r16, r30
		code[i] = temp;
     642:	f7 01       	movw	r30, r14
     644:	b1 92       	st	Z+, r11
     646:	7f 01       	movw	r14, r30
		if(temp != '#')
     648:	f3 e2       	ldi	r31, 0x23	; 35
     64a:	bf 16       	cp	r11, r31
     64c:	29 f0       	breq	.+10     	; 0x658 <change_code+0x7e>
			LCD_DisplayString(1, n_code);
     64e:	be 01       	movw	r22, r28
     650:	6f 5f       	subi	r22, 0xFF	; 255
     652:	7f 4f       	sbci	r23, 0xFF	; 255
     654:	81 e0       	ldi	r24, 0x01	; 1
     656:	f1 de       	rcall	.-542    	; 0x43a <LCD_DisplayString>
void change_code()
{
	char temp = '\0';
	char n_code[6] = {' ',' ',' ',' ',' ','\0'};	
	LCD_DisplayString(1, enter_new_code_string);
	for(int i = 0; i < 5; i++)
     658:	0c 15       	cp	r16, r12
     65a:	1d 05       	cpc	r17, r13
     65c:	41 f7       	brne	.-48     	; 0x62e <change_code+0x54>
		code[i] = temp;
		if(temp != '#')
			LCD_DisplayString(1, n_code);
		temp = '\0';
	}
}
     65e:	26 96       	adiw	r28, 0x06	; 6
     660:	0f b6       	in	r0, 0x3f	; 63
     662:	f8 94       	cli
     664:	de bf       	out	0x3e, r29	; 62
     666:	0f be       	out	0x3f, r0	; 63
     668:	cd bf       	out	0x3d, r28	; 61
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	0f 91       	pop	r16
     672:	ff 90       	pop	r15
     674:	ef 90       	pop	r14
     676:	df 90       	pop	r13
     678:	cf 90       	pop	r12
     67a:	bf 90       	pop	r11
     67c:	08 95       	ret

0000067e <LCD_tick>:

void LCD_tick()
{
	// Actions
	switch(lcd_state)
     67e:	80 91 44 08 	lds	r24, 0x0844
     682:	82 30       	cpi	r24, 0x02	; 2
     684:	09 f4       	brne	.+2      	; 0x688 <LCD_tick+0xa>
     686:	3c c0       	rjmp	.+120    	; 0x700 <LCD_tick+0x82>
     688:	30 f4       	brcc	.+12     	; 0x696 <LCD_tick+0x18>
     68a:	88 23       	and	r24, r24
     68c:	59 f0       	breq	.+22     	; 0x6a4 <LCD_tick+0x26>
     68e:	81 30       	cpi	r24, 0x01	; 1
     690:	09 f0       	breq	.+2      	; 0x694 <LCD_tick+0x16>
     692:	5c c0       	rjmp	.+184    	; 0x74c <LCD_tick+0xce>
     694:	18 c0       	rjmp	.+48     	; 0x6c6 <LCD_tick+0x48>
     696:	83 30       	cpi	r24, 0x03	; 3
     698:	09 f4       	brne	.+2      	; 0x69c <LCD_tick+0x1e>
     69a:	41 c0       	rjmp	.+130    	; 0x71e <LCD_tick+0xa0>
     69c:	84 30       	cpi	r24, 0x04	; 4
     69e:	09 f0       	breq	.+2      	; 0x6a2 <LCD_tick+0x24>
     6a0:	55 c0       	rjmp	.+170    	; 0x74c <LCD_tick+0xce>
     6a2:	49 c0       	rjmp	.+146    	; 0x736 <LCD_tick+0xb8>
	{
		case LCDinit:
			(page == 1) ? LCD_DisplayString(1, page_one) : LCD_DisplayString(1, page_two);
     6a4:	80 91 4c 08 	lds	r24, 0x084C
     6a8:	81 30       	cpi	r24, 0x01	; 1
     6aa:	31 f4       	brne	.+12     	; 0x6b8 <LCD_tick+0x3a>
     6ac:	60 91 15 01 	lds	r22, 0x0115
     6b0:	70 91 16 01 	lds	r23, 0x0116
     6b4:	c2 de       	rcall	.-636    	; 0x43a <LCD_DisplayString>
     6b6:	4a c0       	rjmp	.+148    	; 0x74c <LCD_tick+0xce>
     6b8:	60 91 13 01 	lds	r22, 0x0113
     6bc:	70 91 14 01 	lds	r23, 0x0114
     6c0:	81 e0       	ldi	r24, 0x01	; 1
     6c2:	bb de       	rcall	.-650    	; 0x43a <LCD_DisplayString>
     6c4:	43 c0       	rjmp	.+134    	; 0x74c <LCD_tick+0xce>
			break;
		case door:
			if(verify_code())
     6c6:	25 df       	rcall	.-438    	; 0x512 <verify_code>
     6c8:	88 23       	and	r24, r24
     6ca:	b9 f0       	breq	.+46     	; 0x6fa <LCD_tick+0x7c>
			{
				motor_engage = true;
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	80 93 4d 08 	sts	0x084D, r24
				(locked) ? LCD_DisplayString(1, unlock_string) : LCD_DisplayString(1, lock_string);
     6d2:	80 91 47 08 	lds	r24, 0x0847
     6d6:	88 23       	and	r24, r24
     6d8:	39 f0       	breq	.+14     	; 0x6e8 <LCD_tick+0x6a>
     6da:	60 91 11 01 	lds	r22, 0x0111
     6de:	70 91 12 01 	lds	r23, 0x0112
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	aa de       	rcall	.-684    	; 0x43a <LCD_DisplayString>
     6e6:	06 c0       	rjmp	.+12     	; 0x6f4 <LCD_tick+0x76>
     6e8:	60 91 0f 01 	lds	r22, 0x010F
     6ec:	70 91 10 01 	lds	r23, 0x0110
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	a3 de       	rcall	.-698    	; 0x43a <LCD_DisplayString>
				delay_ms(1500);
     6f4:	8c ed       	ldi	r24, 0xDC	; 220
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	66 de       	rcall	.-820    	; 0x3c6 <delay_ms>
			}
			choice = NULL;
     6fa:	10 92 48 08 	sts	0x0848, r1
			break;
     6fe:	26 c0       	rjmp	.+76     	; 0x74c <LCD_tick+0xce>
		case ch_code:
			LCD_DisplayString(1, change_code_string);
     700:	60 91 0d 01 	lds	r22, 0x010D
     704:	70 91 0e 01 	lds	r23, 0x010E
     708:	81 e0       	ldi	r24, 0x01	; 1
     70a:	97 de       	rcall	.-722    	; 0x43a <LCD_DisplayString>
			delay_ms(1500);
     70c:	8c ed       	ldi	r24, 0xDC	; 220
     70e:	95 e0       	ldi	r25, 0x05	; 5
     710:	5a de       	rcall	.-844    	; 0x3c6 <delay_ms>
			if(verify_code())
     712:	ff de       	rcall	.-514    	; 0x512 <verify_code>
     714:	81 11       	cpse	r24, r1
				change_code();
     716:	61 df       	rcall	.-318    	; 0x5da <change_code>
			choice = NULL;
     718:	10 92 48 08 	sts	0x0848, r1
			break;
     71c:	17 c0       	rjmp	.+46     	; 0x74c <LCD_tick+0xce>
		case n_page:
			page = (page == 1) ? 2 : 1;
     71e:	80 91 4c 08 	lds	r24, 0x084C
     722:	81 30       	cpi	r24, 0x01	; 1
     724:	11 f4       	brne	.+4      	; 0x72a <LCD_tick+0xac>
     726:	82 e0       	ldi	r24, 0x02	; 2
     728:	01 c0       	rjmp	.+2      	; 0x72c <LCD_tick+0xae>
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	80 93 4c 08 	sts	0x084C, r24
			choice = NULL;
     730:	10 92 48 08 	sts	0x0848, r1
			break;
     734:	0b c0       	rjmp	.+22     	; 0x74c <LCD_tick+0xce>
		case set_thermo:
			LCD_DisplayString(1, set_thermo_string);
     736:	60 91 0b 01 	lds	r22, 0x010B
     73a:	70 91 0c 01 	lds	r23, 0x010C
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	7c de       	rcall	.-776    	; 0x43a <LCD_DisplayString>
			delay_ms(1500);
     742:	8c ed       	ldi	r24, 0xDC	; 220
     744:	95 e0       	ldi	r25, 0x05	; 5
     746:	3f de       	rcall	.-898    	; 0x3c6 <delay_ms>
			choice = NULL;
     748:	10 92 48 08 	sts	0x0848, r1
			break;
	}
	
	// Transitions
	switch(lcd_state)
     74c:	80 91 44 08 	lds	r24, 0x0844
     750:	82 30       	cpi	r24, 0x02	; 2
     752:	51 f1       	breq	.+84     	; 0x7a8 <LCD_tick+0x12a>
     754:	28 f4       	brcc	.+10     	; 0x760 <LCD_tick+0xe2>
     756:	88 23       	and	r24, r24
     758:	41 f0       	breq	.+16     	; 0x76a <LCD_tick+0xec>
     75a:	81 30       	cpi	r24, 0x01	; 1
     75c:	69 f5       	brne	.+90     	; 0x7b8 <LCD_tick+0x13a>
     75e:	21 c0       	rjmp	.+66     	; 0x7a2 <LCD_tick+0x124>
     760:	83 30       	cpi	r24, 0x03	; 3
     762:	29 f1       	breq	.+74     	; 0x7ae <LCD_tick+0x130>
     764:	84 30       	cpi	r24, 0x04	; 4
     766:	41 f5       	brne	.+80     	; 0x7b8 <LCD_tick+0x13a>
     768:	25 c0       	rjmp	.+74     	; 0x7b4 <LCD_tick+0x136>
	{
		case LCDinit:
			if(choice == '\0' || choice == NULL)
     76a:	80 91 48 08 	lds	r24, 0x0848
     76e:	88 23       	and	r24, r24
     770:	19 f1       	breq	.+70     	; 0x7b8 <LCD_tick+0x13a>
				break;
			else if(choice == 'A')
     772:	81 34       	cpi	r24, 0x41	; 65
     774:	21 f4       	brne	.+8      	; 0x77e <LCD_tick+0x100>
				lcd_state = door;
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	80 93 44 08 	sts	0x0844, r24
     77c:	08 95       	ret
			else if(choice == 'B')
     77e:	82 34       	cpi	r24, 0x42	; 66
     780:	21 f4       	brne	.+8      	; 0x78a <LCD_tick+0x10c>
				lcd_state = ch_code;
     782:	82 e0       	ldi	r24, 0x02	; 2
     784:	80 93 44 08 	sts	0x0844, r24
     788:	08 95       	ret
			else if(choice == 'C')
     78a:	83 34       	cpi	r24, 0x43	; 67
     78c:	21 f4       	brne	.+8      	; 0x796 <LCD_tick+0x118>
				lcd_state = n_page;
     78e:	83 e0       	ldi	r24, 0x03	; 3
     790:	80 93 44 08 	sts	0x0844, r24
     794:	08 95       	ret
			else if(choice == 'D')
     796:	84 34       	cpi	r24, 0x44	; 68
     798:	79 f4       	brne	.+30     	; 0x7b8 <LCD_tick+0x13a>
				lcd_state = set_thermo;
     79a:	84 e0       	ldi	r24, 0x04	; 4
     79c:	80 93 44 08 	sts	0x0844, r24
     7a0:	08 95       	ret
			else
				break;
			break;
		case door:
			lcd_state = LCDinit;
     7a2:	10 92 44 08 	sts	0x0844, r1
			break;
     7a6:	08 95       	ret
		case ch_code:
			lcd_state = LCDinit;
     7a8:	10 92 44 08 	sts	0x0844, r1
			break;
     7ac:	08 95       	ret
		case n_page:
			lcd_state = LCDinit;
     7ae:	10 92 44 08 	sts	0x0844, r1
			break;
     7b2:	08 95       	ret
		case set_thermo:
			lcd_state = LCDinit;
     7b4:	10 92 44 08 	sts	0x0844, r1
     7b8:	08 95       	ret

000007ba <Motor_Tick>:
enum motorState {motor_init,L0,L1,L2,L3,L4,L5,L6,L7} motor_state;

void Motor_Tick()
{
	// Transitions
	switch(motor_state)
     7ba:	80 91 46 08 	lds	r24, 0x0846
     7be:	84 30       	cpi	r24, 0x04	; 4
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <Motor_Tick+0xa>
     7c2:	99 c0       	rjmp	.+306    	; 0x8f6 <Motor_Tick+0x13c>
     7c4:	50 f4       	brcc	.+20     	; 0x7da <Motor_Tick+0x20>
     7c6:	81 30       	cpi	r24, 0x01	; 1
     7c8:	51 f1       	breq	.+84     	; 0x81e <Motor_Tick+0x64>
     7ca:	98 f0       	brcs	.+38     	; 0x7f2 <Motor_Tick+0x38>
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <Motor_Tick+0x18>
     7d0:	4a c0       	rjmp	.+148    	; 0x866 <Motor_Tick+0xac>
     7d2:	83 30       	cpi	r24, 0x03	; 3
     7d4:	09 f0       	breq	.+2      	; 0x7d8 <Motor_Tick+0x1e>
     7d6:	42 c1       	rjmp	.+644    	; 0xa5c <Motor_Tick+0x2a2>
     7d8:	6a c0       	rjmp	.+212    	; 0x8ae <Motor_Tick+0xf4>
     7da:	86 30       	cpi	r24, 0x06	; 6
     7dc:	09 f4       	brne	.+2      	; 0x7e0 <Motor_Tick+0x26>
     7de:	d3 c0       	rjmp	.+422    	; 0x986 <Motor_Tick+0x1cc>
     7e0:	08 f4       	brcc	.+2      	; 0x7e4 <Motor_Tick+0x2a>
     7e2:	ad c0       	rjmp	.+346    	; 0x93e <Motor_Tick+0x184>
     7e4:	87 30       	cpi	r24, 0x07	; 7
     7e6:	09 f4       	brne	.+2      	; 0x7ea <Motor_Tick+0x30>
     7e8:	f2 c0       	rjmp	.+484    	; 0x9ce <Motor_Tick+0x214>
     7ea:	88 30       	cpi	r24, 0x08	; 8
     7ec:	09 f0       	breq	.+2      	; 0x7f0 <Motor_Tick+0x36>
     7ee:	36 c1       	rjmp	.+620    	; 0xa5c <Motor_Tick+0x2a2>
     7f0:	12 c1       	rjmp	.+548    	; 0xa16 <Motor_Tick+0x25c>
	{
		case motor_init:
			if(motor_engage && locked)
     7f2:	80 91 4d 08 	lds	r24, 0x084D
     7f6:	88 23       	and	r24, r24
     7f8:	09 f4       	brne	.+2      	; 0x7fc <Motor_Tick+0x42>
     7fa:	4b c1       	rjmp	.+662    	; 0xa92 <Motor_Tick+0x2d8>
     7fc:	80 91 47 08 	lds	r24, 0x0847
     800:	88 23       	and	r24, r24
     802:	31 f0       	breq	.+12     	; 0x810 <Motor_Tick+0x56>
			{
				motor_state = L0;
     804:	81 e0       	ldi	r24, 0x01	; 1
     806:	80 93 46 08 	sts	0x0846, r24
				direction = 1;
     80a:	80 93 45 08 	sts	0x0845, r24
     80e:	26 c1       	rjmp	.+588    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(motor_engage && !locked)
			{
				motor_state = L7;
     810:	88 e0       	ldi	r24, 0x08	; 8
     812:	80 93 46 08 	sts	0x0846, r24
				direction = 2;
     816:	82 e0       	ldi	r24, 0x02	; 2
     818:	80 93 45 08 	sts	0x0845, r24
     81c:	1f c1       	rjmp	.+574    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else
				break;
			break;
		case L0:
			if(motor_cnt == one_eighty)
     81e:	20 91 42 08 	lds	r18, 0x0842
     822:	30 91 43 08 	lds	r19, 0x0843
     826:	80 91 49 08 	lds	r24, 0x0849
     82a:	90 91 4a 08 	lds	r25, 0x084A
     82e:	28 17       	cp	r18, r24
     830:	39 07       	cpc	r19, r25
     832:	69 f4       	brne	.+26     	; 0x84e <Motor_Tick+0x94>
			{
				motor_state = motor_init;
     834:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     838:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	90 91 45 08 	lds	r25, 0x0845
     842:	91 30       	cpi	r25, 0x01	; 1
     844:	09 f4       	brne	.+2      	; 0x848 <Motor_Tick+0x8e>
     846:	80 e0       	ldi	r24, 0x00	; 0
     848:	80 93 47 08 	sts	0x0847, r24
     84c:	07 c1       	rjmp	.+526    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     84e:	80 91 45 08 	lds	r24, 0x0845
     852:	81 30       	cpi	r24, 0x01	; 1
     854:	21 f4       	brne	.+8      	; 0x85e <Motor_Tick+0xa4>
				motor_state = L1;
     856:	82 e0       	ldi	r24, 0x02	; 2
     858:	80 93 46 08 	sts	0x0846, r24
     85c:	2d c1       	rjmp	.+602    	; 0xab8 <Motor_Tick+0x2fe>
			else
				motor_state = L7;
     85e:	88 e0       	ldi	r24, 0x08	; 8
     860:	80 93 46 08 	sts	0x0846, r24
     864:	7d c1       	rjmp	.+762    	; 0xb60 <Motor_Tick+0x3a6>
			break;
		case L1:
			if(motor_cnt == one_eighty)
     866:	20 91 42 08 	lds	r18, 0x0842
     86a:	30 91 43 08 	lds	r19, 0x0843
     86e:	80 91 49 08 	lds	r24, 0x0849
     872:	90 91 4a 08 	lds	r25, 0x084A
     876:	28 17       	cp	r18, r24
     878:	39 07       	cpc	r19, r25
     87a:	69 f4       	brne	.+26     	; 0x896 <Motor_Tick+0xdc>
			{
				motor_state = motor_init;
     87c:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     880:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 91 45 08 	lds	r25, 0x0845
     88a:	91 30       	cpi	r25, 0x01	; 1
     88c:	09 f4       	brne	.+2      	; 0x890 <Motor_Tick+0xd6>
     88e:	80 e0       	ldi	r24, 0x00	; 0
     890:	80 93 47 08 	sts	0x0847, r24
     894:	e3 c0       	rjmp	.+454    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     896:	80 91 45 08 	lds	r24, 0x0845
     89a:	81 30       	cpi	r24, 0x01	; 1
     89c:	21 f4       	brne	.+8      	; 0x8a6 <Motor_Tick+0xec>
				motor_state = L2;
     89e:	83 e0       	ldi	r24, 0x03	; 3
     8a0:	80 93 46 08 	sts	0x0846, r24
     8a4:	17 c1       	rjmp	.+558    	; 0xad4 <Motor_Tick+0x31a>
			else
				motor_state = L0;
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	80 93 46 08 	sts	0x0846, r24
     8ac:	f7 c0       	rjmp	.+494    	; 0xa9c <Motor_Tick+0x2e2>
			break;
		case L2:
			if(motor_cnt == one_eighty)
     8ae:	20 91 42 08 	lds	r18, 0x0842
     8b2:	30 91 43 08 	lds	r19, 0x0843
     8b6:	80 91 49 08 	lds	r24, 0x0849
     8ba:	90 91 4a 08 	lds	r25, 0x084A
     8be:	28 17       	cp	r18, r24
     8c0:	39 07       	cpc	r19, r25
     8c2:	69 f4       	brne	.+26     	; 0x8de <Motor_Tick+0x124>
			{
				motor_state = motor_init;
     8c4:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     8c8:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	90 91 45 08 	lds	r25, 0x0845
     8d2:	91 30       	cpi	r25, 0x01	; 1
     8d4:	09 f4       	brne	.+2      	; 0x8d8 <Motor_Tick+0x11e>
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	80 93 47 08 	sts	0x0847, r24
     8dc:	bf c0       	rjmp	.+382    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     8de:	80 91 45 08 	lds	r24, 0x0845
     8e2:	81 30       	cpi	r24, 0x01	; 1
     8e4:	21 f4       	brne	.+8      	; 0x8ee <Motor_Tick+0x134>
				motor_state = L3;
     8e6:	84 e0       	ldi	r24, 0x04	; 4
     8e8:	80 93 46 08 	sts	0x0846, r24
     8ec:	01 c1       	rjmp	.+514    	; 0xaf0 <Motor_Tick+0x336>
			else
				motor_state = L1;
     8ee:	82 e0       	ldi	r24, 0x02	; 2
     8f0:	80 93 46 08 	sts	0x0846, r24
     8f4:	e1 c0       	rjmp	.+450    	; 0xab8 <Motor_Tick+0x2fe>
			break;
		case L3:
			if(motor_cnt == one_eighty)
     8f6:	20 91 42 08 	lds	r18, 0x0842
     8fa:	30 91 43 08 	lds	r19, 0x0843
     8fe:	80 91 49 08 	lds	r24, 0x0849
     902:	90 91 4a 08 	lds	r25, 0x084A
     906:	28 17       	cp	r18, r24
     908:	39 07       	cpc	r19, r25
     90a:	69 f4       	brne	.+26     	; 0x926 <Motor_Tick+0x16c>
			{
				motor_state = motor_init;
     90c:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     910:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	90 91 45 08 	lds	r25, 0x0845
     91a:	91 30       	cpi	r25, 0x01	; 1
     91c:	09 f4       	brne	.+2      	; 0x920 <Motor_Tick+0x166>
     91e:	80 e0       	ldi	r24, 0x00	; 0
     920:	80 93 47 08 	sts	0x0847, r24
     924:	9b c0       	rjmp	.+310    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     926:	80 91 45 08 	lds	r24, 0x0845
     92a:	81 30       	cpi	r24, 0x01	; 1
     92c:	21 f4       	brne	.+8      	; 0x936 <Motor_Tick+0x17c>
				motor_state = L4;
     92e:	85 e0       	ldi	r24, 0x05	; 5
     930:	80 93 46 08 	sts	0x0846, r24
     934:	eb c0       	rjmp	.+470    	; 0xb0c <Motor_Tick+0x352>
			else
				motor_state = L2;
     936:	83 e0       	ldi	r24, 0x03	; 3
     938:	80 93 46 08 	sts	0x0846, r24
     93c:	cb c0       	rjmp	.+406    	; 0xad4 <Motor_Tick+0x31a>
			break;
		case L4:
			if(motor_cnt == one_eighty)
     93e:	20 91 42 08 	lds	r18, 0x0842
     942:	30 91 43 08 	lds	r19, 0x0843
     946:	80 91 49 08 	lds	r24, 0x0849
     94a:	90 91 4a 08 	lds	r25, 0x084A
     94e:	28 17       	cp	r18, r24
     950:	39 07       	cpc	r19, r25
     952:	69 f4       	brne	.+26     	; 0x96e <Motor_Tick+0x1b4>
			{
				motor_state = motor_init;
     954:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     958:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     95c:	81 e0       	ldi	r24, 0x01	; 1
     95e:	90 91 45 08 	lds	r25, 0x0845
     962:	91 30       	cpi	r25, 0x01	; 1
     964:	09 f4       	brne	.+2      	; 0x968 <Motor_Tick+0x1ae>
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	80 93 47 08 	sts	0x0847, r24
     96c:	77 c0       	rjmp	.+238    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     96e:	80 91 45 08 	lds	r24, 0x0845
     972:	81 30       	cpi	r24, 0x01	; 1
     974:	21 f4       	brne	.+8      	; 0x97e <Motor_Tick+0x1c4>
				motor_state = L5;
     976:	86 e0       	ldi	r24, 0x06	; 6
     978:	80 93 46 08 	sts	0x0846, r24
     97c:	d5 c0       	rjmp	.+426    	; 0xb28 <Motor_Tick+0x36e>
			else
				motor_state = L3;
     97e:	84 e0       	ldi	r24, 0x04	; 4
     980:	80 93 46 08 	sts	0x0846, r24
     984:	b5 c0       	rjmp	.+362    	; 0xaf0 <Motor_Tick+0x336>
			break;
		case L5:
			if(motor_cnt == one_eighty)
     986:	20 91 42 08 	lds	r18, 0x0842
     98a:	30 91 43 08 	lds	r19, 0x0843
     98e:	80 91 49 08 	lds	r24, 0x0849
     992:	90 91 4a 08 	lds	r25, 0x084A
     996:	28 17       	cp	r18, r24
     998:	39 07       	cpc	r19, r25
     99a:	69 f4       	brne	.+26     	; 0x9b6 <Motor_Tick+0x1fc>
			{
				motor_state = motor_init;
     99c:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     9a0:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	90 91 45 08 	lds	r25, 0x0845
     9aa:	91 30       	cpi	r25, 0x01	; 1
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <Motor_Tick+0x1f6>
     9ae:	80 e0       	ldi	r24, 0x00	; 0
     9b0:	80 93 47 08 	sts	0x0847, r24
     9b4:	53 c0       	rjmp	.+166    	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     9b6:	80 91 45 08 	lds	r24, 0x0845
     9ba:	81 30       	cpi	r24, 0x01	; 1
     9bc:	21 f4       	brne	.+8      	; 0x9c6 <Motor_Tick+0x20c>
				motor_state = L6;
     9be:	87 e0       	ldi	r24, 0x07	; 7
     9c0:	80 93 46 08 	sts	0x0846, r24
     9c4:	bf c0       	rjmp	.+382    	; 0xb44 <Motor_Tick+0x38a>
			else
				motor_state = L4;
     9c6:	85 e0       	ldi	r24, 0x05	; 5
     9c8:	80 93 46 08 	sts	0x0846, r24
     9cc:	9f c0       	rjmp	.+318    	; 0xb0c <Motor_Tick+0x352>
			break;
		case L6:
			if(motor_cnt == one_eighty)
     9ce:	20 91 42 08 	lds	r18, 0x0842
     9d2:	30 91 43 08 	lds	r19, 0x0843
     9d6:	80 91 49 08 	lds	r24, 0x0849
     9da:	90 91 4a 08 	lds	r25, 0x084A
     9de:	28 17       	cp	r18, r24
     9e0:	39 07       	cpc	r19, r25
     9e2:	69 f4       	brne	.+26     	; 0x9fe <Motor_Tick+0x244>
			{
				motor_state = motor_init;
     9e4:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     9e8:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     9ec:	81 e0       	ldi	r24, 0x01	; 1
     9ee:	90 91 45 08 	lds	r25, 0x0845
     9f2:	91 30       	cpi	r25, 0x01	; 1
     9f4:	09 f4       	brne	.+2      	; 0x9f8 <Motor_Tick+0x23e>
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	80 93 47 08 	sts	0x0847, r24
     9fc:	2f c0       	rjmp	.+94     	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     9fe:	80 91 45 08 	lds	r24, 0x0845
     a02:	81 30       	cpi	r24, 0x01	; 1
     a04:	21 f4       	brne	.+8      	; 0xa0e <Motor_Tick+0x254>
				motor_state = L7;
     a06:	88 e0       	ldi	r24, 0x08	; 8
     a08:	80 93 46 08 	sts	0x0846, r24
     a0c:	a9 c0       	rjmp	.+338    	; 0xb60 <Motor_Tick+0x3a6>
			else
				motor_state = L5;
     a0e:	86 e0       	ldi	r24, 0x06	; 6
     a10:	80 93 46 08 	sts	0x0846, r24
     a14:	89 c0       	rjmp	.+274    	; 0xb28 <Motor_Tick+0x36e>
			break;
		case L7:
			if(motor_cnt == one_eighty)
     a16:	20 91 42 08 	lds	r18, 0x0842
     a1a:	30 91 43 08 	lds	r19, 0x0843
     a1e:	80 91 49 08 	lds	r24, 0x0849
     a22:	90 91 4a 08 	lds	r25, 0x084A
     a26:	28 17       	cp	r18, r24
     a28:	39 07       	cpc	r19, r25
     a2a:	69 f4       	brne	.+26     	; 0xa46 <Motor_Tick+0x28c>
			{
				motor_state = motor_init;
     a2c:	10 92 46 08 	sts	0x0846, r1
				motor_engage = false;
     a30:	10 92 4d 08 	sts	0x084D, r1
				locked = (direction == 1) ? false : true;
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	90 91 45 08 	lds	r25, 0x0845
     a3a:	91 30       	cpi	r25, 0x01	; 1
     a3c:	09 f4       	brne	.+2      	; 0xa40 <Motor_Tick+0x286>
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	80 93 47 08 	sts	0x0847, r24
     a44:	0b c0       	rjmp	.+22     	; 0xa5c <Motor_Tick+0x2a2>
			}
			else if(direction == 1)
     a46:	80 91 45 08 	lds	r24, 0x0845
     a4a:	81 30       	cpi	r24, 0x01	; 1
     a4c:	19 f4       	brne	.+6      	; 0xa54 <Motor_Tick+0x29a>
				motor_state = L0;
     a4e:	80 93 46 08 	sts	0x0846, r24
     a52:	24 c0       	rjmp	.+72     	; 0xa9c <Motor_Tick+0x2e2>
			else
				motor_state = L6;
     a54:	87 e0       	ldi	r24, 0x07	; 7
     a56:	80 93 46 08 	sts	0x0846, r24
     a5a:	74 c0       	rjmp	.+232    	; 0xb44 <Motor_Tick+0x38a>
			break;
	}
	// Actions (Phases are left-shifted two bits to 
	//          accomodate LCD output of A0, A1)
	switch(motor_state)
     a5c:	80 91 46 08 	lds	r24, 0x0846
     a60:	84 30       	cpi	r24, 0x04	; 4
     a62:	09 f4       	brne	.+2      	; 0xa66 <Motor_Tick+0x2ac>
     a64:	45 c0       	rjmp	.+138    	; 0xaf0 <Motor_Tick+0x336>
     a66:	48 f4       	brcc	.+18     	; 0xa7a <Motor_Tick+0x2c0>
     a68:	81 30       	cpi	r24, 0x01	; 1
     a6a:	c1 f0       	breq	.+48     	; 0xa9c <Motor_Tick+0x2e2>
     a6c:	90 f0       	brcs	.+36     	; 0xa92 <Motor_Tick+0x2d8>
     a6e:	82 30       	cpi	r24, 0x02	; 2
     a70:	19 f1       	breq	.+70     	; 0xab8 <Motor_Tick+0x2fe>
     a72:	83 30       	cpi	r24, 0x03	; 3
     a74:	09 f0       	breq	.+2      	; 0xa78 <Motor_Tick+0x2be>
     a76:	81 c0       	rjmp	.+258    	; 0xb7a <Motor_Tick+0x3c0>
     a78:	2d c0       	rjmp	.+90     	; 0xad4 <Motor_Tick+0x31a>
     a7a:	86 30       	cpi	r24, 0x06	; 6
     a7c:	09 f4       	brne	.+2      	; 0xa80 <Motor_Tick+0x2c6>
     a7e:	54 c0       	rjmp	.+168    	; 0xb28 <Motor_Tick+0x36e>
     a80:	08 f4       	brcc	.+2      	; 0xa84 <Motor_Tick+0x2ca>
     a82:	44 c0       	rjmp	.+136    	; 0xb0c <Motor_Tick+0x352>
     a84:	87 30       	cpi	r24, 0x07	; 7
     a86:	09 f4       	brne	.+2      	; 0xa8a <Motor_Tick+0x2d0>
     a88:	5d c0       	rjmp	.+186    	; 0xb44 <Motor_Tick+0x38a>
     a8a:	88 30       	cpi	r24, 0x08	; 8
     a8c:	09 f0       	breq	.+2      	; 0xa90 <Motor_Tick+0x2d6>
     a8e:	75 c0       	rjmp	.+234    	; 0xb7a <Motor_Tick+0x3c0>
     a90:	67 c0       	rjmp	.+206    	; 0xb60 <Motor_Tick+0x3a6>
	{
		case motor_init:
			motor_cnt = 0;
     a92:	10 92 43 08 	sts	0x0843, r1
     a96:	10 92 42 08 	sts	0x0842, r1
			break;
     a9a:	08 95       	ret
		case L0:
			motor_phase = 0x04;
     a9c:	84 e0       	ldi	r24, 0x04	; 4
     a9e:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     aa2:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     aa4:	80 91 42 08 	lds	r24, 0x0842
     aa8:	90 91 43 08 	lds	r25, 0x0843
     aac:	03 96       	adiw	r24, 0x03	; 3
     aae:	90 93 43 08 	sts	0x0843, r25
     ab2:	80 93 42 08 	sts	0x0842, r24
			break;
     ab6:	08 95       	ret
		case L1:
			motor_phase = 0x0C;
     ab8:	8c e0       	ldi	r24, 0x0C	; 12
     aba:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     abe:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     ac0:	80 91 42 08 	lds	r24, 0x0842
     ac4:	90 91 43 08 	lds	r25, 0x0843
     ac8:	03 96       	adiw	r24, 0x03	; 3
     aca:	90 93 43 08 	sts	0x0843, r25
     ace:	80 93 42 08 	sts	0x0842, r24
			break;
     ad2:	08 95       	ret
		case L2:
			motor_phase = 0x08;
     ad4:	88 e0       	ldi	r24, 0x08	; 8
     ad6:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     ada:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     adc:	80 91 42 08 	lds	r24, 0x0842
     ae0:	90 91 43 08 	lds	r25, 0x0843
     ae4:	03 96       	adiw	r24, 0x03	; 3
     ae6:	90 93 43 08 	sts	0x0843, r25
     aea:	80 93 42 08 	sts	0x0842, r24
			break;
     aee:	08 95       	ret
		case L3:
			motor_phase = 0x18;
     af0:	88 e1       	ldi	r24, 0x18	; 24
     af2:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     af6:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     af8:	80 91 42 08 	lds	r24, 0x0842
     afc:	90 91 43 08 	lds	r25, 0x0843
     b00:	03 96       	adiw	r24, 0x03	; 3
     b02:	90 93 43 08 	sts	0x0843, r25
     b06:	80 93 42 08 	sts	0x0842, r24
			break;
     b0a:	08 95       	ret
		case L4:
			motor_phase = 0x10;
     b0c:	80 e1       	ldi	r24, 0x10	; 16
     b0e:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     b12:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     b14:	80 91 42 08 	lds	r24, 0x0842
     b18:	90 91 43 08 	lds	r25, 0x0843
     b1c:	03 96       	adiw	r24, 0x03	; 3
     b1e:	90 93 43 08 	sts	0x0843, r25
     b22:	80 93 42 08 	sts	0x0842, r24
			break;
     b26:	08 95       	ret
		case L5:
			motor_phase = 0x30;
     b28:	80 e3       	ldi	r24, 0x30	; 48
     b2a:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     b2e:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     b30:	80 91 42 08 	lds	r24, 0x0842
     b34:	90 91 43 08 	lds	r25, 0x0843
     b38:	03 96       	adiw	r24, 0x03	; 3
     b3a:	90 93 43 08 	sts	0x0843, r25
     b3e:	80 93 42 08 	sts	0x0842, r24
			break;
     b42:	08 95       	ret
		case L6:
			motor_phase = 0x20;
     b44:	80 e2       	ldi	r24, 0x20	; 32
     b46:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     b4a:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     b4c:	80 91 42 08 	lds	r24, 0x0842
     b50:	90 91 43 08 	lds	r25, 0x0843
     b54:	03 96       	adiw	r24, 0x03	; 3
     b56:	90 93 43 08 	sts	0x0843, r25
     b5a:	80 93 42 08 	sts	0x0842, r24
			break;
     b5e:	08 95       	ret
		case L7:
			motor_phase = 0x24;
     b60:	84 e2       	ldi	r24, 0x24	; 36
     b62:	80 93 4b 08 	sts	0x084B, r24
			//PORTA = PORTA | motor_phase;
			PORTA = motor_phase;
     b66:	82 b9       	out	0x02, r24	; 2
			motor_cnt += 3;
     b68:	80 91 42 08 	lds	r24, 0x0842
     b6c:	90 91 43 08 	lds	r25, 0x0843
     b70:	03 96       	adiw	r24, 0x03	; 3
     b72:	90 93 43 08 	sts	0x0843, r25
     b76:	80 93 42 08 	sts	0x0842, r24
     b7a:	08 95       	ret

00000b7c <motor_Init>:
	}
}

void motor_Init()
{
	motor_state = motor_init;
     b7c:	10 92 46 08 	sts	0x0846, r1
	motor_phase = 0x00;
     b80:	10 92 4b 08 	sts	0x084B, r1
	one_eighty = 6144;
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	98 e1       	ldi	r25, 0x18	; 24
     b88:	90 93 4a 08 	sts	0x084A, r25
     b8c:	80 93 49 08 	sts	0x0849, r24
	direction = 0;
     b90:	10 92 45 08 	sts	0x0845, r1
	motor_cnt = 0;
     b94:	10 92 43 08 	sts	0x0843, r1
     b98:	10 92 42 08 	sts	0x0842, r1
     b9c:	08 95       	ret

00000b9e <MotorTask>:
}

void MotorTask()
{
	motor_Init();
     b9e:	ee df       	rcall	.-36     	; 0xb7c <motor_Init>
	for(;;)
	{
		Motor_Tick();
     ba0:	0c de       	rcall	.-1000   	; 0x7ba <Motor_Tick>
		vTaskDelay(3);
     ba2:	83 e0       	ldi	r24, 0x03	; 3
     ba4:	90 e0       	ldi	r25, 0x00	; 0
     ba6:	d8 d4       	rcall	.+2480   	; 0x1558 <vTaskDelay>
     ba8:	fb cf       	rjmp	.-10     	; 0xba0 <MotorTask+0x2>

00000baa <key_Init>:
	}
}

void key_Init()
{
	key_state = INITK;
     baa:	10 92 4e 08 	sts	0x084E, r1
	choice = NULL;
     bae:	10 92 48 08 	sts	0x0848, r1
     bb2:	08 95       	ret

00000bb4 <KeyTask>:
}

void KeyTask() 
{
	key_Init();
     bb4:	fa df       	rcall	.-12     	; 0xbaa <key_Init>
	for(;;)
	{
		Key_Tick();
     bb6:	58 dc       	rcall	.-1872   	; 0x468 <Key_Tick>
		vTaskDelay(100);
     bb8:	84 e6       	ldi	r24, 0x64	; 100
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	cd d4       	rcall	.+2458   	; 0x1558 <vTaskDelay>
     bbe:	fb cf       	rjmp	.-10     	; 0xbb6 <KeyTask+0x2>

00000bc0 <LCD_task_init>:
	}
}

void LCD_task_init()
{
	locked = true;
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	80 93 47 08 	sts	0x0847, r24
	page = 1;
     bc6:	80 93 4c 08 	sts	0x084C, r24
	lcd_state = LCDinit;
     bca:	10 92 44 08 	sts	0x0844, r1
     bce:	08 95       	ret

00000bd0 <LCDTask>:
}

void LCDTask()
{
	LCD_task_init();
     bd0:	f7 df       	rcall	.-18     	; 0xbc0 <LCD_task_init>
	LCD_init();
     bd2:	17 dc       	rcall	.-2002   	; 0x402 <LCD_init>
	LCD_DisplayString(1, s);
     bd4:	60 91 17 01 	lds	r22, 0x0117
     bd8:	70 91 18 01 	lds	r23, 0x0118
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	2d dc       	rcall	.-1958   	; 0x43a <LCD_DisplayString>
	delay_ms(3000);
     be0:	88 eb       	ldi	r24, 0xB8	; 184
     be2:	9b e0       	ldi	r25, 0x0B	; 11
     be4:	f0 db       	rcall	.-2080   	; 0x3c6 <delay_ms>
	for(;;) 
	{
		LCD_tick();
     be6:	4b dd       	rcall	.-1386   	; 0x67e <LCD_tick>
		vTaskDelay(500);
     be8:	84 ef       	ldi	r24, 0xF4	; 244
     bea:	91 e0       	ldi	r25, 0x01	; 1
     bec:	b5 d4       	rcall	.+2410   	; 0x1558 <vTaskDelay>
     bee:	fb cf       	rjmp	.-10     	; 0xbe6 <LCDTask+0x16>

00000bf0 <StartSecPulse>:
	}
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
     bf0:	af 92       	push	r10
     bf2:	bf 92       	push	r11
     bf4:	cf 92       	push	r12
     bf6:	df 92       	push	r13
     bf8:	ef 92       	push	r14
     bfa:	ff 92       	push	r15
     bfc:	0f 93       	push	r16
     bfe:	cf 93       	push	r28
	xTaskCreate(KeyTask, (signed portCHAR *)"KeyTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     c00:	a1 2c       	mov	r10, r1
     c02:	b1 2c       	mov	r11, r1
     c04:	c1 2c       	mov	r12, r1
     c06:	d1 2c       	mov	r13, r1
     c08:	e1 2c       	mov	r14, r1
     c0a:	f1 2c       	mov	r15, r1
     c0c:	08 2f       	mov	r16, r24
     c0e:	20 e0       	ldi	r18, 0x00	; 0
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	45 e5       	ldi	r20, 0x55	; 85
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	61 e2       	ldi	r22, 0x21	; 33
     c18:	71 e0       	ldi	r23, 0x01	; 1
     c1a:	8a ed       	ldi	r24, 0xDA	; 218
     c1c:	95 e0       	ldi	r25, 0x05	; 5
     c1e:	e2 d1       	rcall	.+964    	; 0xfe4 <xTaskGenericCreate>
	xTaskCreate(LCDTask, (signed portCHAR *)"LCDTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     c20:	20 e0       	ldi	r18, 0x00	; 0
     c22:	30 e0       	ldi	r19, 0x00	; 0
     c24:	45 e5       	ldi	r20, 0x55	; 85
     c26:	50 e0       	ldi	r21, 0x00	; 0
     c28:	69 e2       	ldi	r22, 0x29	; 41
     c2a:	71 e0       	ldi	r23, 0x01	; 1
     c2c:	88 ee       	ldi	r24, 0xE8	; 232
     c2e:	95 e0       	ldi	r25, 0x05	; 5
     c30:	d9 d1       	rcall	.+946    	; 0xfe4 <xTaskGenericCreate>
	xTaskCreate(MotorTask, (signed portCHAR *)"MotorTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     c32:	20 e0       	ldi	r18, 0x00	; 0
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	45 e5       	ldi	r20, 0x55	; 85
     c38:	50 e0       	ldi	r21, 0x00	; 0
     c3a:	61 e3       	ldi	r22, 0x31	; 49
     c3c:	71 e0       	ldi	r23, 0x01	; 1
     c3e:	8f ec       	ldi	r24, 0xCF	; 207
     c40:	95 e0       	ldi	r25, 0x05	; 5
     c42:	d0 d1       	rcall	.+928    	; 0xfe4 <xTaskGenericCreate>
}	
     c44:	cf 91       	pop	r28
     c46:	0f 91       	pop	r16
     c48:	ff 90       	pop	r15
     c4a:	ef 90       	pop	r14
     c4c:	df 90       	pop	r13
     c4e:	cf 90       	pop	r12
     c50:	bf 90       	pop	r11
     c52:	af 90       	pop	r10
     c54:	08 95       	ret

00000c56 <main>:

int main(void) 
{
	DDRA = 0xFF; PORTA = 0x00;
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	81 b9       	out	0x01, r24	; 1
     c5a:	12 b8       	out	0x02, r1	; 2
	DDRB = 0xFF; PORTB = 0x00;
     c5c:	84 b9       	out	0x04, r24	; 4
     c5e:	15 b8       	out	0x05, r1	; 5
	DDRC = 0xF0; PORTC = 0x0F;
     c60:	90 ef       	ldi	r25, 0xF0	; 240
     c62:	97 b9       	out	0x07, r25	; 7
     c64:	9f e0       	ldi	r25, 0x0F	; 15
     c66:	98 b9       	out	0x08, r25	; 8
	DDRD = 0xFF; PORTD = 0x00;
     c68:	8a b9       	out	0x0a, r24	; 10
     c6a:	1b b8       	out	0x0b, r1	; 11

	//Start Tasks  
	StartSecPulse(1);
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	c0 df       	rcall	.-128    	; 0xbf0 <StartSecPulse>
	//RunSchedular 
	vTaskStartScheduler(); 
     c70:	b7 d2       	rcall	.+1390   	; 0x11e0 <vTaskStartScheduler>

	return 0; 
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	08 95       	ret

00000c78 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c78:	31 e1       	ldi	r19, 0x11	; 17
     c7a:	fc 01       	movw	r30, r24
     c7c:	30 83       	st	Z, r19
     c7e:	31 97       	sbiw	r30, 0x01	; 1
     c80:	22 e2       	ldi	r18, 0x22	; 34
     c82:	20 83       	st	Z, r18
     c84:	fc 01       	movw	r30, r24
     c86:	32 97       	sbiw	r30, 0x02	; 2
     c88:	a3 e3       	ldi	r26, 0x33	; 51
     c8a:	a0 83       	st	Z, r26
     c8c:	fc 01       	movw	r30, r24
     c8e:	33 97       	sbiw	r30, 0x03	; 3
     c90:	60 83       	st	Z, r22
     c92:	fc 01       	movw	r30, r24
     c94:	34 97       	sbiw	r30, 0x04	; 4
     c96:	70 83       	st	Z, r23
     c98:	fc 01       	movw	r30, r24
     c9a:	35 97       	sbiw	r30, 0x05	; 5
     c9c:	10 82       	st	Z, r1
     c9e:	fc 01       	movw	r30, r24
     ca0:	36 97       	sbiw	r30, 0x06	; 6
     ca2:	60 e8       	ldi	r22, 0x80	; 128
     ca4:	60 83       	st	Z, r22
     ca6:	fc 01       	movw	r30, r24
     ca8:	37 97       	sbiw	r30, 0x07	; 7
     caa:	10 82       	st	Z, r1
     cac:	fc 01       	movw	r30, r24
     cae:	38 97       	sbiw	r30, 0x08	; 8
     cb0:	62 e0       	ldi	r22, 0x02	; 2
     cb2:	60 83       	st	Z, r22
     cb4:	fc 01       	movw	r30, r24
     cb6:	39 97       	sbiw	r30, 0x09	; 9
     cb8:	63 e0       	ldi	r22, 0x03	; 3
     cba:	60 83       	st	Z, r22
     cbc:	fc 01       	movw	r30, r24
     cbe:	3a 97       	sbiw	r30, 0x0a	; 10
     cc0:	64 e0       	ldi	r22, 0x04	; 4
     cc2:	60 83       	st	Z, r22
     cc4:	fc 01       	movw	r30, r24
     cc6:	3b 97       	sbiw	r30, 0x0b	; 11
     cc8:	65 e0       	ldi	r22, 0x05	; 5
     cca:	60 83       	st	Z, r22
     ccc:	fc 01       	movw	r30, r24
     cce:	3c 97       	sbiw	r30, 0x0c	; 12
     cd0:	66 e0       	ldi	r22, 0x06	; 6
     cd2:	60 83       	st	Z, r22
     cd4:	fc 01       	movw	r30, r24
     cd6:	3d 97       	sbiw	r30, 0x0d	; 13
     cd8:	67 e0       	ldi	r22, 0x07	; 7
     cda:	60 83       	st	Z, r22
     cdc:	fc 01       	movw	r30, r24
     cde:	3e 97       	sbiw	r30, 0x0e	; 14
     ce0:	68 e0       	ldi	r22, 0x08	; 8
     ce2:	60 83       	st	Z, r22
     ce4:	fc 01       	movw	r30, r24
     ce6:	3f 97       	sbiw	r30, 0x0f	; 15
     ce8:	69 e0       	ldi	r22, 0x09	; 9
     cea:	60 83       	st	Z, r22
     cec:	fc 01       	movw	r30, r24
     cee:	70 97       	sbiw	r30, 0x10	; 16
     cf0:	60 e1       	ldi	r22, 0x10	; 16
     cf2:	60 83       	st	Z, r22
     cf4:	fc 01       	movw	r30, r24
     cf6:	71 97       	sbiw	r30, 0x11	; 17
     cf8:	30 83       	st	Z, r19
     cfa:	fc 01       	movw	r30, r24
     cfc:	72 97       	sbiw	r30, 0x12	; 18
     cfe:	32 e1       	ldi	r19, 0x12	; 18
     d00:	30 83       	st	Z, r19
     d02:	fc 01       	movw	r30, r24
     d04:	73 97       	sbiw	r30, 0x13	; 19
     d06:	33 e1       	ldi	r19, 0x13	; 19
     d08:	30 83       	st	Z, r19
     d0a:	fc 01       	movw	r30, r24
     d0c:	74 97       	sbiw	r30, 0x14	; 20
     d0e:	34 e1       	ldi	r19, 0x14	; 20
     d10:	30 83       	st	Z, r19
     d12:	fc 01       	movw	r30, r24
     d14:	75 97       	sbiw	r30, 0x15	; 21
     d16:	35 e1       	ldi	r19, 0x15	; 21
     d18:	30 83       	st	Z, r19
     d1a:	fc 01       	movw	r30, r24
     d1c:	76 97       	sbiw	r30, 0x16	; 22
     d1e:	36 e1       	ldi	r19, 0x16	; 22
     d20:	30 83       	st	Z, r19
     d22:	fc 01       	movw	r30, r24
     d24:	77 97       	sbiw	r30, 0x17	; 23
     d26:	37 e1       	ldi	r19, 0x17	; 23
     d28:	30 83       	st	Z, r19
     d2a:	fc 01       	movw	r30, r24
     d2c:	78 97       	sbiw	r30, 0x18	; 24
     d2e:	38 e1       	ldi	r19, 0x18	; 24
     d30:	30 83       	st	Z, r19
     d32:	fc 01       	movw	r30, r24
     d34:	79 97       	sbiw	r30, 0x19	; 25
     d36:	39 e1       	ldi	r19, 0x19	; 25
     d38:	30 83       	st	Z, r19
     d3a:	fc 01       	movw	r30, r24
     d3c:	7a 97       	sbiw	r30, 0x1a	; 26
     d3e:	30 e2       	ldi	r19, 0x20	; 32
     d40:	30 83       	st	Z, r19
     d42:	fc 01       	movw	r30, r24
     d44:	7b 97       	sbiw	r30, 0x1b	; 27
     d46:	31 e2       	ldi	r19, 0x21	; 33
     d48:	30 83       	st	Z, r19
     d4a:	fc 01       	movw	r30, r24
     d4c:	7c 97       	sbiw	r30, 0x1c	; 28
     d4e:	20 83       	st	Z, r18
     d50:	fc 01       	movw	r30, r24
     d52:	7d 97       	sbiw	r30, 0x1d	; 29
     d54:	23 e2       	ldi	r18, 0x23	; 35
     d56:	20 83       	st	Z, r18
     d58:	fc 01       	movw	r30, r24
     d5a:	7e 97       	sbiw	r30, 0x1e	; 30
     d5c:	40 83       	st	Z, r20
     d5e:	fc 01       	movw	r30, r24
     d60:	7f 97       	sbiw	r30, 0x1f	; 31
     d62:	50 83       	st	Z, r21
     d64:	fc 01       	movw	r30, r24
     d66:	b0 97       	sbiw	r30, 0x20	; 32
     d68:	26 e2       	ldi	r18, 0x26	; 38
     d6a:	20 83       	st	Z, r18
     d6c:	fc 01       	movw	r30, r24
     d6e:	b1 97       	sbiw	r30, 0x21	; 33
     d70:	27 e2       	ldi	r18, 0x27	; 39
     d72:	20 83       	st	Z, r18
     d74:	fc 01       	movw	r30, r24
     d76:	b2 97       	sbiw	r30, 0x22	; 34
     d78:	28 e2       	ldi	r18, 0x28	; 40
     d7a:	20 83       	st	Z, r18
     d7c:	fc 01       	movw	r30, r24
     d7e:	b3 97       	sbiw	r30, 0x23	; 35
     d80:	29 e2       	ldi	r18, 0x29	; 41
     d82:	20 83       	st	Z, r18
     d84:	fc 01       	movw	r30, r24
     d86:	b4 97       	sbiw	r30, 0x24	; 36
     d88:	20 e3       	ldi	r18, 0x30	; 48
     d8a:	20 83       	st	Z, r18
     d8c:	fc 01       	movw	r30, r24
     d8e:	b5 97       	sbiw	r30, 0x25	; 37
     d90:	21 e3       	ldi	r18, 0x31	; 49
     d92:	20 83       	st	Z, r18
     d94:	9c 01       	movw	r18, r24
     d96:	26 52       	subi	r18, 0x26	; 38
     d98:	31 09       	sbc	r19, r1
     d9a:	82 2f       	mov	r24, r18
     d9c:	93 2f       	mov	r25, r19
     d9e:	08 95       	ret

00000da0 <xPortStartScheduler>:
     da0:	10 92 89 00 	sts	0x0089, r1
     da4:	8c e7       	ldi	r24, 0x7C	; 124
     da6:	80 93 88 00 	sts	0x0088, r24
     daa:	8b e0       	ldi	r24, 0x0B	; 11
     dac:	80 93 81 00 	sts	0x0081, r24
     db0:	ef e6       	ldi	r30, 0x6F	; 111
     db2:	f0 e0       	ldi	r31, 0x00	; 0
     db4:	80 81       	ld	r24, Z
     db6:	82 60       	ori	r24, 0x02	; 2
     db8:	80 83       	st	Z, r24
     dba:	a0 91 f6 07 	lds	r26, 0x07F6
     dbe:	b0 91 f7 07 	lds	r27, 0x07F7
     dc2:	cd 91       	ld	r28, X+
     dc4:	cd bf       	out	0x3d, r28	; 61
     dc6:	dd 91       	ld	r29, X+
     dc8:	de bf       	out	0x3e, r29	; 62
     dca:	ff 91       	pop	r31
     dcc:	ef 91       	pop	r30
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	bf 91       	pop	r27
     dd4:	af 91       	pop	r26
     dd6:	9f 91       	pop	r25
     dd8:	8f 91       	pop	r24
     dda:	7f 91       	pop	r23
     ddc:	6f 91       	pop	r22
     dde:	5f 91       	pop	r21
     de0:	4f 91       	pop	r20
     de2:	3f 91       	pop	r19
     de4:	2f 91       	pop	r18
     de6:	1f 91       	pop	r17
     de8:	0f 91       	pop	r16
     dea:	ff 90       	pop	r15
     dec:	ef 90       	pop	r14
     dee:	df 90       	pop	r13
     df0:	cf 90       	pop	r12
     df2:	bf 90       	pop	r11
     df4:	af 90       	pop	r10
     df6:	9f 90       	pop	r9
     df8:	8f 90       	pop	r8
     dfa:	7f 90       	pop	r7
     dfc:	6f 90       	pop	r6
     dfe:	5f 90       	pop	r5
     e00:	4f 90       	pop	r4
     e02:	3f 90       	pop	r3
     e04:	2f 90       	pop	r2
     e06:	1f 90       	pop	r1
     e08:	0f 90       	pop	r0
     e0a:	0f be       	out	0x3f, r0	; 63
     e0c:	0f 90       	pop	r0
     e0e:	08 95       	ret
     e10:	81 e0       	ldi	r24, 0x01	; 1
     e12:	08 95       	ret

00000e14 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e14:	0f 92       	push	r0
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	0f 92       	push	r0
     e1c:	1f 92       	push	r1
     e1e:	11 24       	eor	r1, r1
     e20:	2f 92       	push	r2
     e22:	3f 92       	push	r3
     e24:	4f 92       	push	r4
     e26:	5f 92       	push	r5
     e28:	6f 92       	push	r6
     e2a:	7f 92       	push	r7
     e2c:	8f 92       	push	r8
     e2e:	9f 92       	push	r9
     e30:	af 92       	push	r10
     e32:	bf 92       	push	r11
     e34:	cf 92       	push	r12
     e36:	df 92       	push	r13
     e38:	ef 92       	push	r14
     e3a:	ff 92       	push	r15
     e3c:	0f 93       	push	r16
     e3e:	1f 93       	push	r17
     e40:	2f 93       	push	r18
     e42:	3f 93       	push	r19
     e44:	4f 93       	push	r20
     e46:	5f 93       	push	r21
     e48:	6f 93       	push	r22
     e4a:	7f 93       	push	r23
     e4c:	8f 93       	push	r24
     e4e:	9f 93       	push	r25
     e50:	af 93       	push	r26
     e52:	bf 93       	push	r27
     e54:	cf 93       	push	r28
     e56:	df 93       	push	r29
     e58:	ef 93       	push	r30
     e5a:	ff 93       	push	r31
     e5c:	a0 91 f6 07 	lds	r26, 0x07F6
     e60:	b0 91 f7 07 	lds	r27, 0x07F7
     e64:	0d b6       	in	r0, 0x3d	; 61
     e66:	0d 92       	st	X+, r0
     e68:	0e b6       	in	r0, 0x3e	; 62
     e6a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e6c:	91 d3       	rcall	.+1826   	; 0x1590 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e6e:	a0 91 f6 07 	lds	r26, 0x07F6
     e72:	b0 91 f7 07 	lds	r27, 0x07F7
     e76:	cd 91       	ld	r28, X+
     e78:	cd bf       	out	0x3d, r28	; 61
     e7a:	dd 91       	ld	r29, X+
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	ff 91       	pop	r31
     e80:	ef 91       	pop	r30
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	bf 91       	pop	r27
     e88:	af 91       	pop	r26
     e8a:	9f 91       	pop	r25
     e8c:	8f 91       	pop	r24
     e8e:	7f 91       	pop	r23
     e90:	6f 91       	pop	r22
     e92:	5f 91       	pop	r21
     e94:	4f 91       	pop	r20
     e96:	3f 91       	pop	r19
     e98:	2f 91       	pop	r18
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	df 90       	pop	r13
     ea4:	cf 90       	pop	r12
     ea6:	bf 90       	pop	r11
     ea8:	af 90       	pop	r10
     eaa:	9f 90       	pop	r9
     eac:	8f 90       	pop	r8
     eae:	7f 90       	pop	r7
     eb0:	6f 90       	pop	r6
     eb2:	5f 90       	pop	r5
     eb4:	4f 90       	pop	r4
     eb6:	3f 90       	pop	r3
     eb8:	2f 90       	pop	r2
     eba:	1f 90       	pop	r1
     ebc:	0f 90       	pop	r0
     ebe:	0f be       	out	0x3f, r0	; 63
     ec0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ec2:	08 95       	ret

00000ec4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ec4:	0f 92       	push	r0
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
     ecc:	1f 92       	push	r1
     ece:	11 24       	eor	r1, r1
     ed0:	2f 92       	push	r2
     ed2:	3f 92       	push	r3
     ed4:	4f 92       	push	r4
     ed6:	5f 92       	push	r5
     ed8:	6f 92       	push	r6
     eda:	7f 92       	push	r7
     edc:	8f 92       	push	r8
     ede:	9f 92       	push	r9
     ee0:	af 92       	push	r10
     ee2:	bf 92       	push	r11
     ee4:	cf 92       	push	r12
     ee6:	df 92       	push	r13
     ee8:	ef 92       	push	r14
     eea:	ff 92       	push	r15
     eec:	0f 93       	push	r16
     eee:	1f 93       	push	r17
     ef0:	2f 93       	push	r18
     ef2:	3f 93       	push	r19
     ef4:	4f 93       	push	r20
     ef6:	5f 93       	push	r21
     ef8:	6f 93       	push	r22
     efa:	7f 93       	push	r23
     efc:	8f 93       	push	r24
     efe:	9f 93       	push	r25
     f00:	af 93       	push	r26
     f02:	bf 93       	push	r27
     f04:	cf 93       	push	r28
     f06:	df 93       	push	r29
     f08:	ef 93       	push	r30
     f0a:	ff 93       	push	r31
     f0c:	a0 91 f6 07 	lds	r26, 0x07F6
     f10:	b0 91 f7 07 	lds	r27, 0x07F7
     f14:	0d b6       	in	r0, 0x3d	; 61
     f16:	0d 92       	st	X+, r0
     f18:	0e b6       	in	r0, 0x3e	; 62
     f1a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     f1c:	90 d1       	rcall	.+800    	; 0x123e <vTaskIncrementTick>
	vTaskSwitchContext();
     f1e:	38 d3       	rcall	.+1648   	; 0x1590 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f20:	a0 91 f6 07 	lds	r26, 0x07F6
     f24:	b0 91 f7 07 	lds	r27, 0x07F7
     f28:	cd 91       	ld	r28, X+
     f2a:	cd bf       	out	0x3d, r28	; 61
     f2c:	dd 91       	ld	r29, X+
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	ff 91       	pop	r31
     f32:	ef 91       	pop	r30
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	bf 91       	pop	r27
     f3a:	af 91       	pop	r26
     f3c:	9f 91       	pop	r25
     f3e:	8f 91       	pop	r24
     f40:	7f 91       	pop	r23
     f42:	6f 91       	pop	r22
     f44:	5f 91       	pop	r21
     f46:	4f 91       	pop	r20
     f48:	3f 91       	pop	r19
     f4a:	2f 91       	pop	r18
     f4c:	1f 91       	pop	r17
     f4e:	0f 91       	pop	r16
     f50:	ff 90       	pop	r15
     f52:	ef 90       	pop	r14
     f54:	df 90       	pop	r13
     f56:	cf 90       	pop	r12
     f58:	bf 90       	pop	r11
     f5a:	af 90       	pop	r10
     f5c:	9f 90       	pop	r9
     f5e:	8f 90       	pop	r8
     f60:	7f 90       	pop	r7
     f62:	6f 90       	pop	r6
     f64:	5f 90       	pop	r5
     f66:	4f 90       	pop	r4
     f68:	3f 90       	pop	r3
     f6a:	2f 90       	pop	r2
     f6c:	1f 90       	pop	r1
     f6e:	0f 90       	pop	r0
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f74:	08 95       	ret

00000f76 <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f76:	a6 df       	rcall	.-180    	; 0xec4 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f78:	18 95       	reti

00000f7a <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	ec 01       	movw	r28, r24
     f80:	e0 91 f6 07 	lds	r30, 0x07F6
     f84:	f0 91 f7 07 	lds	r31, 0x07F7
     f88:	93 83       	std	Z+3, r25	; 0x03
     f8a:	82 83       	std	Z+2, r24	; 0x02
     f8c:	80 91 ee 07 	lds	r24, 0x07EE
     f90:	90 91 ef 07 	lds	r25, 0x07EF
     f94:	c8 17       	cp	r28, r24
     f96:	d9 07       	cpc	r29, r25
     f98:	60 f4       	brcc	.+24     	; 0xfb2 <prvAddCurrentTaskToDelayedList+0x38>
     f9a:	60 91 f6 07 	lds	r22, 0x07F6
     f9e:	70 91 f7 07 	lds	r23, 0x07F7
     fa2:	80 91 f2 07 	lds	r24, 0x07F2
     fa6:	90 91 f3 07 	lds	r25, 0x07F3
     faa:	6e 5f       	subi	r22, 0xFE	; 254
     fac:	7f 4f       	sbci	r23, 0xFF	; 255
     fae:	ee d8       	rcall	.-3620   	; 0x18c <vListInsert>
     fb0:	16 c0       	rjmp	.+44     	; 0xfde <prvAddCurrentTaskToDelayedList+0x64>
     fb2:	60 91 f6 07 	lds	r22, 0x07F6
     fb6:	70 91 f7 07 	lds	r23, 0x07F7
     fba:	80 91 f4 07 	lds	r24, 0x07F4
     fbe:	90 91 f5 07 	lds	r25, 0x07F5
     fc2:	6e 5f       	subi	r22, 0xFE	; 254
     fc4:	7f 4f       	sbci	r23, 0xFF	; 255
     fc6:	e2 d8       	rcall	.-3644   	; 0x18c <vListInsert>
     fc8:	80 91 19 01 	lds	r24, 0x0119
     fcc:	90 91 1a 01 	lds	r25, 0x011A
     fd0:	c8 17       	cp	r28, r24
     fd2:	d9 07       	cpc	r29, r25
     fd4:	20 f4       	brcc	.+8      	; 0xfde <prvAddCurrentTaskToDelayedList+0x64>
     fd6:	d0 93 1a 01 	sts	0x011A, r29
     fda:	c0 93 19 01 	sts	0x0119, r28
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	08 95       	ret

00000fe4 <xTaskGenericCreate>:
     fe4:	4f 92       	push	r4
     fe6:	5f 92       	push	r5
     fe8:	6f 92       	push	r6
     fea:	7f 92       	push	r7
     fec:	8f 92       	push	r8
     fee:	9f 92       	push	r9
     ff0:	af 92       	push	r10
     ff2:	bf 92       	push	r11
     ff4:	cf 92       	push	r12
     ff6:	df 92       	push	r13
     ff8:	ef 92       	push	r14
     ffa:	ff 92       	push	r15
     ffc:	0f 93       	push	r16
     ffe:	1f 93       	push	r17
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	4c 01       	movw	r8, r24
    1006:	3b 01       	movw	r6, r22
    1008:	5a 01       	movw	r10, r20
    100a:	29 01       	movw	r4, r18
    100c:	81 e2       	ldi	r24, 0x21	; 33
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	5c d8       	rcall	.-3912   	; 0xca <pvPortMalloc>
    1012:	ec 01       	movw	r28, r24
    1014:	00 97       	sbiw	r24, 0x00	; 0
    1016:	09 f4       	brne	.+2      	; 0x101a <xTaskGenericCreate+0x36>
    1018:	d1 c0       	rjmp	.+418    	; 0x11bc <xTaskGenericCreate+0x1d8>
    101a:	c1 14       	cp	r12, r1
    101c:	d1 04       	cpc	r13, r1
    101e:	09 f0       	breq	.+2      	; 0x1022 <xTaskGenericCreate+0x3e>
    1020:	ca c0       	rjmp	.+404    	; 0x11b6 <xTaskGenericCreate+0x1d2>
    1022:	c5 01       	movw	r24, r10
    1024:	52 d8       	rcall	.-3932   	; 0xca <pvPortMalloc>
    1026:	6c 01       	movw	r12, r24
    1028:	98 8f       	std	Y+24, r25	; 0x18
    102a:	8f 8b       	std	Y+23, r24	; 0x17
    102c:	00 97       	sbiw	r24, 0x00	; 0
    102e:	19 f4       	brne	.+6      	; 0x1036 <xTaskGenericCreate+0x52>
    1030:	ce 01       	movw	r24, r28
    1032:	72 d8       	rcall	.-3868   	; 0x118 <vPortFree>
    1034:	c3 c0       	rjmp	.+390    	; 0x11bc <xTaskGenericCreate+0x1d8>
    1036:	a5 01       	movw	r20, r10
    1038:	65 ea       	ldi	r22, 0xA5	; 165
    103a:	70 e0       	ldi	r23, 0x00	; 0
    103c:	c6 01       	movw	r24, r12
    103e:	05 d3       	rcall	.+1546   	; 0x164a <memset>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	a8 1a       	sub	r10, r24
    1044:	b1 08       	sbc	r11, r1
    1046:	8f 89       	ldd	r24, Y+23	; 0x17
    1048:	98 8d       	ldd	r25, Y+24	; 0x18
    104a:	a8 0e       	add	r10, r24
    104c:	b9 1e       	adc	r11, r25
    104e:	48 e0       	ldi	r20, 0x08	; 8
    1050:	50 e0       	ldi	r21, 0x00	; 0
    1052:	b3 01       	movw	r22, r6
    1054:	ce 01       	movw	r24, r28
    1056:	49 96       	adiw	r24, 0x19	; 25
    1058:	ff d2       	rcall	.+1534   	; 0x1658 <strncpy>
    105a:	18 a2       	std	Y+32, r1	; 0x20
    105c:	10 2f       	mov	r17, r16
    105e:	04 30       	cpi	r16, 0x04	; 4
    1060:	08 f0       	brcs	.+2      	; 0x1064 <xTaskGenericCreate+0x80>
    1062:	13 e0       	ldi	r17, 0x03	; 3
    1064:	1e 8b       	std	Y+22, r17	; 0x16
    1066:	6e 01       	movw	r12, r28
    1068:	e2 e0       	ldi	r30, 0x02	; 2
    106a:	ce 0e       	add	r12, r30
    106c:	d1 1c       	adc	r13, r1
    106e:	c6 01       	movw	r24, r12
    1070:	62 d8       	rcall	.-3900   	; 0x136 <vListInitialiseItem>
    1072:	ce 01       	movw	r24, r28
    1074:	0c 96       	adiw	r24, 0x0c	; 12
    1076:	5f d8       	rcall	.-3906   	; 0x136 <vListInitialiseItem>
    1078:	d9 87       	std	Y+9, r29	; 0x09
    107a:	c8 87       	std	Y+8, r28	; 0x08
    107c:	84 e0       	ldi	r24, 0x04	; 4
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	81 1b       	sub	r24, r17
    1082:	91 09       	sbc	r25, r1
    1084:	9d 87       	std	Y+13, r25	; 0x0d
    1086:	8c 87       	std	Y+12, r24	; 0x0c
    1088:	db 8b       	std	Y+19, r29	; 0x13
    108a:	ca 8b       	std	Y+18, r28	; 0x12
    108c:	a2 01       	movw	r20, r4
    108e:	b4 01       	movw	r22, r8
    1090:	c5 01       	movw	r24, r10
    1092:	f2 dd       	rcall	.-1052   	; 0xc78 <pxPortInitialiseStack>
    1094:	99 83       	std	Y+1, r25	; 0x01
    1096:	88 83       	st	Y, r24
    1098:	e1 14       	cp	r14, r1
    109a:	f1 04       	cpc	r15, r1
    109c:	19 f0       	breq	.+6      	; 0x10a4 <xTaskGenericCreate+0xc0>
    109e:	f7 01       	movw	r30, r14
    10a0:	d1 83       	std	Z+1, r29	; 0x01
    10a2:	c0 83       	st	Z, r28
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	f8 94       	cli
    10a8:	0f 92       	push	r0
    10aa:	80 91 f0 07 	lds	r24, 0x07F0
    10ae:	8f 5f       	subi	r24, 0xFF	; 255
    10b0:	80 93 f0 07 	sts	0x07F0, r24
    10b4:	80 91 f6 07 	lds	r24, 0x07F6
    10b8:	90 91 f7 07 	lds	r25, 0x07F7
    10bc:	89 2b       	or	r24, r25
    10be:	b9 f5       	brne	.+110    	; 0x112e <xTaskGenericCreate+0x14a>
    10c0:	d0 93 f7 07 	sts	0x07F7, r29
    10c4:	c0 93 f6 07 	sts	0x07F6, r28
    10c8:	80 91 f0 07 	lds	r24, 0x07F0
    10cc:	81 30       	cpi	r24, 0x01	; 1
    10ce:	09 f0       	breq	.+2      	; 0x10d2 <xTaskGenericCreate+0xee>
    10d0:	3d c0       	rjmp	.+122    	; 0x114c <xTaskGenericCreate+0x168>
    10d2:	e1 2c       	mov	r14, r1
    10d4:	f1 2c       	mov	r15, r1
    10d6:	c7 01       	movw	r24, r14
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	88 0f       	add	r24, r24
    10de:	99 1f       	adc	r25, r25
    10e0:	88 0f       	add	r24, r24
    10e2:	99 1f       	adc	r25, r25
    10e4:	8e 0d       	add	r24, r14
    10e6:	9f 1d       	adc	r25, r15
    10e8:	86 50       	subi	r24, 0x06	; 6
    10ea:	98 4f       	sbci	r25, 0xF8	; 248
    10ec:	16 d8       	rcall	.-4052   	; 0x11a <vListInitialise>
    10ee:	ff ef       	ldi	r31, 0xFF	; 255
    10f0:	ef 1a       	sub	r14, r31
    10f2:	ff 0a       	sbc	r15, r31
    10f4:	84 e0       	ldi	r24, 0x04	; 4
    10f6:	e8 16       	cp	r14, r24
    10f8:	f1 04       	cpc	r15, r1
    10fa:	69 f7       	brne	.-38     	; 0x10d6 <xTaskGenericCreate+0xf2>
    10fc:	8e e1       	ldi	r24, 0x1E	; 30
    10fe:	98 e0       	ldi	r25, 0x08	; 8
    1100:	0c d8       	rcall	.-4072   	; 0x11a <vListInitialise>
    1102:	87 e2       	ldi	r24, 0x27	; 39
    1104:	98 e0       	ldi	r25, 0x08	; 8
    1106:	09 d8       	rcall	.-4078   	; 0x11a <vListInitialise>
    1108:	80 e3       	ldi	r24, 0x30	; 48
    110a:	98 e0       	ldi	r25, 0x08	; 8
    110c:	06 d8       	rcall	.-4084   	; 0x11a <vListInitialise>
    110e:	89 e3       	ldi	r24, 0x39	; 57
    1110:	98 e0       	ldi	r25, 0x08	; 8
    1112:	03 d8       	rcall	.-4090   	; 0x11a <vListInitialise>
    1114:	8e e1       	ldi	r24, 0x1E	; 30
    1116:	98 e0       	ldi	r25, 0x08	; 8
    1118:	90 93 f5 07 	sts	0x07F5, r25
    111c:	80 93 f4 07 	sts	0x07F4, r24
    1120:	87 e2       	ldi	r24, 0x27	; 39
    1122:	98 e0       	ldi	r25, 0x08	; 8
    1124:	90 93 f3 07 	sts	0x07F3, r25
    1128:	80 93 f2 07 	sts	0x07F2, r24
    112c:	0f c0       	rjmp	.+30     	; 0x114c <xTaskGenericCreate+0x168>
    112e:	80 91 ec 07 	lds	r24, 0x07EC
    1132:	81 11       	cpse	r24, r1
    1134:	0b c0       	rjmp	.+22     	; 0x114c <xTaskGenericCreate+0x168>
    1136:	e0 91 f6 07 	lds	r30, 0x07F6
    113a:	f0 91 f7 07 	lds	r31, 0x07F7
    113e:	86 89       	ldd	r24, Z+22	; 0x16
    1140:	08 17       	cp	r16, r24
    1142:	20 f0       	brcs	.+8      	; 0x114c <xTaskGenericCreate+0x168>
    1144:	d0 93 f7 07 	sts	0x07F7, r29
    1148:	c0 93 f6 07 	sts	0x07F6, r28
    114c:	8e 89       	ldd	r24, Y+22	; 0x16
    114e:	90 91 f8 07 	lds	r25, 0x07F8
    1152:	98 17       	cp	r25, r24
    1154:	10 f4       	brcc	.+4      	; 0x115a <xTaskGenericCreate+0x176>
    1156:	80 93 f8 07 	sts	0x07F8, r24
    115a:	90 91 f9 07 	lds	r25, 0x07F9
    115e:	9f 5f       	subi	r25, 0xFF	; 255
    1160:	90 93 f9 07 	sts	0x07F9, r25
    1164:	90 91 ed 07 	lds	r25, 0x07ED
    1168:	98 17       	cp	r25, r24
    116a:	10 f4       	brcc	.+4      	; 0x1170 <xTaskGenericCreate+0x18c>
    116c:	80 93 ed 07 	sts	0x07ED, r24
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	9c 01       	movw	r18, r24
    1174:	22 0f       	add	r18, r18
    1176:	33 1f       	adc	r19, r19
    1178:	22 0f       	add	r18, r18
    117a:	33 1f       	adc	r19, r19
    117c:	22 0f       	add	r18, r18
    117e:	33 1f       	adc	r19, r19
    1180:	82 0f       	add	r24, r18
    1182:	93 1f       	adc	r25, r19
    1184:	b6 01       	movw	r22, r12
    1186:	86 50       	subi	r24, 0x06	; 6
    1188:	98 4f       	sbci	r25, 0xF8	; 248
    118a:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInsertEnd>
    118e:	0f 90       	pop	r0
    1190:	0f be       	out	0x3f, r0	; 63
    1192:	80 91 ec 07 	lds	r24, 0x07EC
    1196:	88 23       	and	r24, r24
    1198:	51 f0       	breq	.+20     	; 0x11ae <xTaskGenericCreate+0x1ca>
    119a:	e0 91 f6 07 	lds	r30, 0x07F6
    119e:	f0 91 f7 07 	lds	r31, 0x07F7
    11a2:	86 89       	ldd	r24, Z+22	; 0x16
    11a4:	80 17       	cp	r24, r16
    11a6:	28 f4       	brcc	.+10     	; 0x11b2 <xTaskGenericCreate+0x1ce>
    11a8:	35 de       	rcall	.-918    	; 0xe14 <vPortYield>
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	08 c0       	rjmp	.+16     	; 0x11be <xTaskGenericCreate+0x1da>
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	06 c0       	rjmp	.+12     	; 0x11be <xTaskGenericCreate+0x1da>
    11b2:	81 e0       	ldi	r24, 0x01	; 1
    11b4:	04 c0       	rjmp	.+8      	; 0x11be <xTaskGenericCreate+0x1da>
    11b6:	d8 8e       	std	Y+24, r13	; 0x18
    11b8:	cf 8a       	std	Y+23, r12	; 0x17
    11ba:	3d cf       	rjmp	.-390    	; 0x1036 <xTaskGenericCreate+0x52>
    11bc:	8f ef       	ldi	r24, 0xFF	; 255
    11be:	df 91       	pop	r29
    11c0:	cf 91       	pop	r28
    11c2:	1f 91       	pop	r17
    11c4:	0f 91       	pop	r16
    11c6:	ff 90       	pop	r15
    11c8:	ef 90       	pop	r14
    11ca:	df 90       	pop	r13
    11cc:	cf 90       	pop	r12
    11ce:	bf 90       	pop	r11
    11d0:	af 90       	pop	r10
    11d2:	9f 90       	pop	r9
    11d4:	8f 90       	pop	r8
    11d6:	7f 90       	pop	r7
    11d8:	6f 90       	pop	r6
    11da:	5f 90       	pop	r5
    11dc:	4f 90       	pop	r4
    11de:	08 95       	ret

000011e0 <vTaskStartScheduler>:
    11e0:	af 92       	push	r10
    11e2:	bf 92       	push	r11
    11e4:	cf 92       	push	r12
    11e6:	df 92       	push	r13
    11e8:	ef 92       	push	r14
    11ea:	ff 92       	push	r15
    11ec:	0f 93       	push	r16
    11ee:	a1 2c       	mov	r10, r1
    11f0:	b1 2c       	mov	r11, r1
    11f2:	c1 2c       	mov	r12, r1
    11f4:	d1 2c       	mov	r13, r1
    11f6:	e1 2c       	mov	r14, r1
    11f8:	f1 2c       	mov	r15, r1
    11fa:	00 e0       	ldi	r16, 0x00	; 0
    11fc:	20 e0       	ldi	r18, 0x00	; 0
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	45 e5       	ldi	r20, 0x55	; 85
    1202:	50 e0       	ldi	r21, 0x00	; 0
    1204:	65 e0       	ldi	r22, 0x05	; 5
    1206:	72 e0       	ldi	r23, 0x02	; 2
    1208:	8f e6       	ldi	r24, 0x6F	; 111
    120a:	9a e0       	ldi	r25, 0x0A	; 10
    120c:	eb de       	rcall	.-554    	; 0xfe4 <xTaskGenericCreate>
    120e:	81 30       	cpi	r24, 0x01	; 1
    1210:	41 f4       	brne	.+16     	; 0x1222 <vTaskStartScheduler+0x42>
    1212:	f8 94       	cli
    1214:	80 93 ec 07 	sts	0x07EC, r24
    1218:	10 92 ef 07 	sts	0x07EF, r1
    121c:	10 92 ee 07 	sts	0x07EE, r1
    1220:	bf dd       	rcall	.-1154   	; 0xda0 <xPortStartScheduler>
    1222:	0f 91       	pop	r16
    1224:	ff 90       	pop	r15
    1226:	ef 90       	pop	r14
    1228:	df 90       	pop	r13
    122a:	cf 90       	pop	r12
    122c:	bf 90       	pop	r11
    122e:	af 90       	pop	r10
    1230:	08 95       	ret

00001232 <vTaskSuspendAll>:
    1232:	80 91 eb 07 	lds	r24, 0x07EB
    1236:	8f 5f       	subi	r24, 0xFF	; 255
    1238:	80 93 eb 07 	sts	0x07EB, r24
    123c:	08 95       	ret

0000123e <vTaskIncrementTick>:
    123e:	0f 93       	push	r16
    1240:	1f 93       	push	r17
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	80 91 eb 07 	lds	r24, 0x07EB
    124a:	81 11       	cpse	r24, r1
    124c:	b2 c0       	rjmp	.+356    	; 0x13b2 <vTaskIncrementTick+0x174>
    124e:	80 91 ee 07 	lds	r24, 0x07EE
    1252:	90 91 ef 07 	lds	r25, 0x07EF
    1256:	01 96       	adiw	r24, 0x01	; 1
    1258:	90 93 ef 07 	sts	0x07EF, r25
    125c:	80 93 ee 07 	sts	0x07EE, r24
    1260:	80 91 ee 07 	lds	r24, 0x07EE
    1264:	90 91 ef 07 	lds	r25, 0x07EF
    1268:	89 2b       	or	r24, r25
    126a:	99 f5       	brne	.+102    	; 0x12d2 <vTaskIncrementTick+0x94>
    126c:	80 91 f4 07 	lds	r24, 0x07F4
    1270:	90 91 f5 07 	lds	r25, 0x07F5
    1274:	20 91 f2 07 	lds	r18, 0x07F2
    1278:	30 91 f3 07 	lds	r19, 0x07F3
    127c:	30 93 f5 07 	sts	0x07F5, r19
    1280:	20 93 f4 07 	sts	0x07F4, r18
    1284:	90 93 f3 07 	sts	0x07F3, r25
    1288:	80 93 f2 07 	sts	0x07F2, r24
    128c:	80 91 e8 07 	lds	r24, 0x07E8
    1290:	8f 5f       	subi	r24, 0xFF	; 255
    1292:	80 93 e8 07 	sts	0x07E8, r24
    1296:	e0 91 f4 07 	lds	r30, 0x07F4
    129a:	f0 91 f5 07 	lds	r31, 0x07F5
    129e:	80 81       	ld	r24, Z
    12a0:	81 11       	cpse	r24, r1
    12a2:	07 c0       	rjmp	.+14     	; 0x12b2 <vTaskIncrementTick+0x74>
    12a4:	8f ef       	ldi	r24, 0xFF	; 255
    12a6:	9f ef       	ldi	r25, 0xFF	; 255
    12a8:	90 93 1a 01 	sts	0x011A, r25
    12ac:	80 93 19 01 	sts	0x0119, r24
    12b0:	10 c0       	rjmp	.+32     	; 0x12d2 <vTaskIncrementTick+0x94>
    12b2:	e0 91 f4 07 	lds	r30, 0x07F4
    12b6:	f0 91 f5 07 	lds	r31, 0x07F5
    12ba:	05 80       	ldd	r0, Z+5	; 0x05
    12bc:	f6 81       	ldd	r31, Z+6	; 0x06
    12be:	e0 2d       	mov	r30, r0
    12c0:	06 80       	ldd	r0, Z+6	; 0x06
    12c2:	f7 81       	ldd	r31, Z+7	; 0x07
    12c4:	e0 2d       	mov	r30, r0
    12c6:	82 81       	ldd	r24, Z+2	; 0x02
    12c8:	93 81       	ldd	r25, Z+3	; 0x03
    12ca:	90 93 1a 01 	sts	0x011A, r25
    12ce:	80 93 19 01 	sts	0x0119, r24
    12d2:	20 91 ee 07 	lds	r18, 0x07EE
    12d6:	30 91 ef 07 	lds	r19, 0x07EF
    12da:	80 91 19 01 	lds	r24, 0x0119
    12de:	90 91 1a 01 	lds	r25, 0x011A
    12e2:	28 17       	cp	r18, r24
    12e4:	39 07       	cpc	r19, r25
    12e6:	08 f4       	brcc	.+2      	; 0x12ea <vTaskIncrementTick+0xac>
    12e8:	69 c0       	rjmp	.+210    	; 0x13bc <vTaskIncrementTick+0x17e>
    12ea:	e0 91 f4 07 	lds	r30, 0x07F4
    12ee:	f0 91 f5 07 	lds	r31, 0x07F5
    12f2:	80 81       	ld	r24, Z
    12f4:	88 23       	and	r24, r24
    12f6:	99 f0       	breq	.+38     	; 0x131e <vTaskIncrementTick+0xe0>
    12f8:	e0 91 f4 07 	lds	r30, 0x07F4
    12fc:	f0 91 f5 07 	lds	r31, 0x07F5
    1300:	05 80       	ldd	r0, Z+5	; 0x05
    1302:	f6 81       	ldd	r31, Z+6	; 0x06
    1304:	e0 2d       	mov	r30, r0
    1306:	c6 81       	ldd	r28, Z+6	; 0x06
    1308:	d7 81       	ldd	r29, Z+7	; 0x07
    130a:	8a 81       	ldd	r24, Y+2	; 0x02
    130c:	9b 81       	ldd	r25, Y+3	; 0x03
    130e:	20 91 ee 07 	lds	r18, 0x07EE
    1312:	30 91 ef 07 	lds	r19, 0x07EF
    1316:	28 17       	cp	r18, r24
    1318:	39 07       	cpc	r19, r25
    131a:	f8 f4       	brcc	.+62     	; 0x135a <vTaskIncrementTick+0x11c>
    131c:	19 c0       	rjmp	.+50     	; 0x1350 <vTaskIncrementTick+0x112>
    131e:	8f ef       	ldi	r24, 0xFF	; 255
    1320:	9f ef       	ldi	r25, 0xFF	; 255
    1322:	90 93 1a 01 	sts	0x011A, r25
    1326:	80 93 19 01 	sts	0x0119, r24
    132a:	48 c0       	rjmp	.+144    	; 0x13bc <vTaskIncrementTick+0x17e>
    132c:	e0 91 f4 07 	lds	r30, 0x07F4
    1330:	f0 91 f5 07 	lds	r31, 0x07F5
    1334:	05 80       	ldd	r0, Z+5	; 0x05
    1336:	f6 81       	ldd	r31, Z+6	; 0x06
    1338:	e0 2d       	mov	r30, r0
    133a:	c6 81       	ldd	r28, Z+6	; 0x06
    133c:	d7 81       	ldd	r29, Z+7	; 0x07
    133e:	8a 81       	ldd	r24, Y+2	; 0x02
    1340:	9b 81       	ldd	r25, Y+3	; 0x03
    1342:	20 91 ee 07 	lds	r18, 0x07EE
    1346:	30 91 ef 07 	lds	r19, 0x07EF
    134a:	28 17       	cp	r18, r24
    134c:	39 07       	cpc	r19, r25
    134e:	28 f4       	brcc	.+10     	; 0x135a <vTaskIncrementTick+0x11c>
    1350:	90 93 1a 01 	sts	0x011A, r25
    1354:	80 93 19 01 	sts	0x0119, r24
    1358:	31 c0       	rjmp	.+98     	; 0x13bc <vTaskIncrementTick+0x17e>
    135a:	8e 01       	movw	r16, r28
    135c:	0e 5f       	subi	r16, 0xFE	; 254
    135e:	1f 4f       	sbci	r17, 0xFF	; 255
    1360:	c8 01       	movw	r24, r16
    1362:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    1366:	8c 89       	ldd	r24, Y+20	; 0x14
    1368:	9d 89       	ldd	r25, Y+21	; 0x15
    136a:	89 2b       	or	r24, r25
    136c:	21 f0       	breq	.+8      	; 0x1376 <vTaskIncrementTick+0x138>
    136e:	ce 01       	movw	r24, r28
    1370:	0c 96       	adiw	r24, 0x0c	; 12
    1372:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    1376:	8e 89       	ldd	r24, Y+22	; 0x16
    1378:	90 91 ed 07 	lds	r25, 0x07ED
    137c:	98 17       	cp	r25, r24
    137e:	10 f4       	brcc	.+4      	; 0x1384 <vTaskIncrementTick+0x146>
    1380:	80 93 ed 07 	sts	0x07ED, r24
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	9c 01       	movw	r18, r24
    1388:	22 0f       	add	r18, r18
    138a:	33 1f       	adc	r19, r19
    138c:	22 0f       	add	r18, r18
    138e:	33 1f       	adc	r19, r19
    1390:	22 0f       	add	r18, r18
    1392:	33 1f       	adc	r19, r19
    1394:	82 0f       	add	r24, r18
    1396:	93 1f       	adc	r25, r19
    1398:	b8 01       	movw	r22, r16
    139a:	86 50       	subi	r24, 0x06	; 6
    139c:	98 4f       	sbci	r25, 0xF8	; 248
    139e:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInsertEnd>
    13a2:	e0 91 f4 07 	lds	r30, 0x07F4
    13a6:	f0 91 f5 07 	lds	r31, 0x07F5
    13aa:	80 81       	ld	r24, Z
    13ac:	81 11       	cpse	r24, r1
    13ae:	be cf       	rjmp	.-132    	; 0x132c <vTaskIncrementTick+0xee>
    13b0:	b6 cf       	rjmp	.-148    	; 0x131e <vTaskIncrementTick+0xe0>
    13b2:	80 91 ea 07 	lds	r24, 0x07EA
    13b6:	8f 5f       	subi	r24, 0xFF	; 255
    13b8:	80 93 ea 07 	sts	0x07EA, r24
    13bc:	df 91       	pop	r29
    13be:	cf 91       	pop	r28
    13c0:	1f 91       	pop	r17
    13c2:	0f 91       	pop	r16
    13c4:	08 95       	ret

000013c6 <xTaskResumeAll>:
    13c6:	af 92       	push	r10
    13c8:	bf 92       	push	r11
    13ca:	cf 92       	push	r12
    13cc:	df 92       	push	r13
    13ce:	ef 92       	push	r14
    13d0:	ff 92       	push	r15
    13d2:	0f 93       	push	r16
    13d4:	1f 93       	push	r17
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
    13e0:	80 91 eb 07 	lds	r24, 0x07EB
    13e4:	81 50       	subi	r24, 0x01	; 1
    13e6:	80 93 eb 07 	sts	0x07EB, r24
    13ea:	80 91 eb 07 	lds	r24, 0x07EB
    13ee:	81 11       	cpse	r24, r1
    13f0:	66 c0       	rjmp	.+204    	; 0x14be <xTaskResumeAll+0xf8>
    13f2:	80 91 f0 07 	lds	r24, 0x07F0
    13f6:	81 11       	cpse	r24, r1
    13f8:	30 c0       	rjmp	.+96     	; 0x145a <xTaskResumeAll+0x94>
    13fa:	64 c0       	rjmp	.+200    	; 0x14c4 <xTaskResumeAll+0xfe>
    13fc:	d6 01       	movw	r26, r12
    13fe:	ed 91       	ld	r30, X+
    1400:	fc 91       	ld	r31, X
    1402:	c6 81       	ldd	r28, Z+6	; 0x06
    1404:	d7 81       	ldd	r29, Z+7	; 0x07
    1406:	ce 01       	movw	r24, r28
    1408:	0c 96       	adiw	r24, 0x0c	; 12
    140a:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    140e:	8e 01       	movw	r16, r28
    1410:	0e 5f       	subi	r16, 0xFE	; 254
    1412:	1f 4f       	sbci	r17, 0xFF	; 255
    1414:	c8 01       	movw	r24, r16
    1416:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    141a:	8e 89       	ldd	r24, Y+22	; 0x16
    141c:	90 91 ed 07 	lds	r25, 0x07ED
    1420:	98 17       	cp	r25, r24
    1422:	10 f4       	brcc	.+4      	; 0x1428 <xTaskResumeAll+0x62>
    1424:	80 93 ed 07 	sts	0x07ED, r24
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	9c 01       	movw	r18, r24
    142c:	22 0f       	add	r18, r18
    142e:	33 1f       	adc	r19, r19
    1430:	22 0f       	add	r18, r18
    1432:	33 1f       	adc	r19, r19
    1434:	22 0f       	add	r18, r18
    1436:	33 1f       	adc	r19, r19
    1438:	82 0f       	add	r24, r18
    143a:	93 1f       	adc	r25, r19
    143c:	b8 01       	movw	r22, r16
    143e:	86 50       	subi	r24, 0x06	; 6
    1440:	98 4f       	sbci	r25, 0xF8	; 248
    1442:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInsertEnd>
    1446:	e0 91 f6 07 	lds	r30, 0x07F6
    144a:	f0 91 f7 07 	lds	r31, 0x07F7
    144e:	9e 89       	ldd	r25, Y+22	; 0x16
    1450:	86 89       	ldd	r24, Z+22	; 0x16
    1452:	98 17       	cp	r25, r24
    1454:	88 f0       	brcs	.+34     	; 0x1478 <xTaskResumeAll+0xb2>
    1456:	ba 2c       	mov	r11, r10
    1458:	0f c0       	rjmp	.+30     	; 0x1478 <xTaskResumeAll+0xb2>
    145a:	b1 2c       	mov	r11, r1
    145c:	0f 2e       	mov	r0, r31
    145e:	f0 e3       	ldi	r31, 0x30	; 48
    1460:	ef 2e       	mov	r14, r31
    1462:	f8 e0       	ldi	r31, 0x08	; 8
    1464:	ff 2e       	mov	r15, r31
    1466:	f0 2d       	mov	r31, r0
    1468:	0f 2e       	mov	r0, r31
    146a:	f5 e3       	ldi	r31, 0x35	; 53
    146c:	cf 2e       	mov	r12, r31
    146e:	f8 e0       	ldi	r31, 0x08	; 8
    1470:	df 2e       	mov	r13, r31
    1472:	f0 2d       	mov	r31, r0
    1474:	aa 24       	eor	r10, r10
    1476:	a3 94       	inc	r10
    1478:	f7 01       	movw	r30, r14
    147a:	80 81       	ld	r24, Z
    147c:	81 11       	cpse	r24, r1
    147e:	be cf       	rjmp	.-132    	; 0x13fc <xTaskResumeAll+0x36>
    1480:	80 91 ea 07 	lds	r24, 0x07EA
    1484:	88 23       	and	r24, r24
    1486:	79 f0       	breq	.+30     	; 0x14a6 <xTaskResumeAll+0xe0>
    1488:	80 91 ea 07 	lds	r24, 0x07EA
    148c:	88 23       	and	r24, r24
    148e:	91 f0       	breq	.+36     	; 0x14b4 <xTaskResumeAll+0xee>
    1490:	d6 de       	rcall	.-596    	; 0x123e <vTaskIncrementTick>
    1492:	80 91 ea 07 	lds	r24, 0x07EA
    1496:	81 50       	subi	r24, 0x01	; 1
    1498:	80 93 ea 07 	sts	0x07EA, r24
    149c:	80 91 ea 07 	lds	r24, 0x07EA
    14a0:	81 11       	cpse	r24, r1
    14a2:	f6 cf       	rjmp	.-20     	; 0x1490 <xTaskResumeAll+0xca>
    14a4:	07 c0       	rjmp	.+14     	; 0x14b4 <xTaskResumeAll+0xee>
    14a6:	f1 e0       	ldi	r31, 0x01	; 1
    14a8:	bf 16       	cp	r11, r31
    14aa:	21 f0       	breq	.+8      	; 0x14b4 <xTaskResumeAll+0xee>
    14ac:	80 91 e9 07 	lds	r24, 0x07E9
    14b0:	81 30       	cpi	r24, 0x01	; 1
    14b2:	39 f4       	brne	.+14     	; 0x14c2 <xTaskResumeAll+0xfc>
    14b4:	10 92 e9 07 	sts	0x07E9, r1
    14b8:	ad dc       	rcall	.-1702   	; 0xe14 <vPortYield>
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	03 c0       	rjmp	.+6      	; 0x14c4 <xTaskResumeAll+0xfe>
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	01 c0       	rjmp	.+2      	; 0x14c4 <xTaskResumeAll+0xfe>
    14c2:	80 e0       	ldi	r24, 0x00	; 0
    14c4:	0f 90       	pop	r0
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	df 91       	pop	r29
    14ca:	cf 91       	pop	r28
    14cc:	1f 91       	pop	r17
    14ce:	0f 91       	pop	r16
    14d0:	ff 90       	pop	r15
    14d2:	ef 90       	pop	r14
    14d4:	df 90       	pop	r13
    14d6:	cf 90       	pop	r12
    14d8:	bf 90       	pop	r11
    14da:	af 90       	pop	r10
    14dc:	08 95       	ret

000014de <prvIdleTask>:
    14de:	0f 2e       	mov	r0, r31
    14e0:	f9 e3       	ldi	r31, 0x39	; 57
    14e2:	ef 2e       	mov	r14, r31
    14e4:	f8 e0       	ldi	r31, 0x08	; 8
    14e6:	ff 2e       	mov	r15, r31
    14e8:	f0 2d       	mov	r31, r0
    14ea:	0f 2e       	mov	r0, r31
    14ec:	fe e3       	ldi	r31, 0x3E	; 62
    14ee:	cf 2e       	mov	r12, r31
    14f0:	f8 e0       	ldi	r31, 0x08	; 8
    14f2:	df 2e       	mov	r13, r31
    14f4:	f0 2d       	mov	r31, r0
    14f6:	ca ef       	ldi	r28, 0xFA	; 250
    14f8:	d7 e0       	ldi	r29, 0x07	; 7
    14fa:	80 91 f1 07 	lds	r24, 0x07F1
    14fe:	88 23       	and	r24, r24
    1500:	31 f1       	breq	.+76     	; 0x154e <prvIdleTask+0x70>
    1502:	97 de       	rcall	.-722    	; 0x1232 <vTaskSuspendAll>
    1504:	d7 01       	movw	r26, r14
    1506:	1c 91       	ld	r17, X
    1508:	5e df       	rcall	.-324    	; 0x13c6 <xTaskResumeAll>
    150a:	11 23       	and	r17, r17
    150c:	01 f1       	breq	.+64     	; 0x154e <prvIdleTask+0x70>
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
    1514:	d6 01       	movw	r26, r12
    1516:	ed 91       	ld	r30, X+
    1518:	fc 91       	ld	r31, X
    151a:	06 81       	ldd	r16, Z+6	; 0x06
    151c:	17 81       	ldd	r17, Z+7	; 0x07
    151e:	c8 01       	movw	r24, r16
    1520:	02 96       	adiw	r24, 0x02	; 2
    1522:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    1526:	80 91 f0 07 	lds	r24, 0x07F0
    152a:	81 50       	subi	r24, 0x01	; 1
    152c:	80 93 f0 07 	sts	0x07F0, r24
    1530:	80 91 f1 07 	lds	r24, 0x07F1
    1534:	81 50       	subi	r24, 0x01	; 1
    1536:	80 93 f1 07 	sts	0x07F1, r24
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	f8 01       	movw	r30, r16
    1540:	87 89       	ldd	r24, Z+23	; 0x17
    1542:	90 8d       	ldd	r25, Z+24	; 0x18
    1544:	0e 94 8c 00 	call	0x118	; 0x118 <vPortFree>
    1548:	c8 01       	movw	r24, r16
    154a:	0e 94 8c 00 	call	0x118	; 0x118 <vPortFree>
    154e:	88 81       	ld	r24, Y
    1550:	82 30       	cpi	r24, 0x02	; 2
    1552:	98 f2       	brcs	.-90     	; 0x14fa <prvIdleTask+0x1c>
    1554:	5f dc       	rcall	.-1858   	; 0xe14 <vPortYield>
    1556:	d1 cf       	rjmp	.-94     	; 0x14fa <prvIdleTask+0x1c>

00001558 <vTaskDelay>:
    1558:	cf 93       	push	r28
    155a:	df 93       	push	r29
    155c:	ec 01       	movw	r28, r24
    155e:	00 97       	sbiw	r24, 0x00	; 0
    1560:	99 f0       	breq	.+38     	; 0x1588 <vTaskDelay+0x30>
    1562:	67 de       	rcall	.-818    	; 0x1232 <vTaskSuspendAll>
    1564:	80 91 ee 07 	lds	r24, 0x07EE
    1568:	90 91 ef 07 	lds	r25, 0x07EF
    156c:	c8 0f       	add	r28, r24
    156e:	d9 1f       	adc	r29, r25
    1570:	80 91 f6 07 	lds	r24, 0x07F6
    1574:	90 91 f7 07 	lds	r25, 0x07F7
    1578:	02 96       	adiw	r24, 0x02	; 2
    157a:	0e 94 01 01 	call	0x202	; 0x202 <vListRemove>
    157e:	ce 01       	movw	r24, r28
    1580:	fc dc       	rcall	.-1544   	; 0xf7a <prvAddCurrentTaskToDelayedList>
    1582:	21 df       	rcall	.-446    	; 0x13c6 <xTaskResumeAll>
    1584:	81 11       	cpse	r24, r1
    1586:	01 c0       	rjmp	.+2      	; 0x158a <vTaskDelay+0x32>
    1588:	45 dc       	rcall	.-1910   	; 0xe14 <vPortYield>
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	08 95       	ret

00001590 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1590:	80 91 eb 07 	lds	r24, 0x07EB
    1594:	81 11       	cpse	r24, r1
    1596:	13 c0       	rjmp	.+38     	; 0x15be <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1598:	80 91 ed 07 	lds	r24, 0x07ED
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	fc 01       	movw	r30, r24
    15a0:	ee 0f       	add	r30, r30
    15a2:	ff 1f       	adc	r31, r31
    15a4:	ee 0f       	add	r30, r30
    15a6:	ff 1f       	adc	r31, r31
    15a8:	ee 0f       	add	r30, r30
    15aa:	ff 1f       	adc	r31, r31
    15ac:	8e 0f       	add	r24, r30
    15ae:	9f 1f       	adc	r25, r31
    15b0:	fc 01       	movw	r30, r24
    15b2:	e6 50       	subi	r30, 0x06	; 6
    15b4:	f8 4f       	sbci	r31, 0xF8	; 248
    15b6:	80 81       	ld	r24, Z
    15b8:	88 23       	and	r24, r24
    15ba:	29 f0       	breq	.+10     	; 0x15c6 <vTaskSwitchContext+0x36>
    15bc:	1b c0       	rjmp	.+54     	; 0x15f4 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    15be:	81 e0       	ldi	r24, 0x01	; 1
    15c0:	80 93 e9 07 	sts	0x07E9, r24
    15c4:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    15c6:	80 91 ed 07 	lds	r24, 0x07ED
    15ca:	81 50       	subi	r24, 0x01	; 1
    15cc:	80 93 ed 07 	sts	0x07ED, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    15d0:	80 91 ed 07 	lds	r24, 0x07ED
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	fc 01       	movw	r30, r24
    15d8:	ee 0f       	add	r30, r30
    15da:	ff 1f       	adc	r31, r31
    15dc:	ee 0f       	add	r30, r30
    15de:	ff 1f       	adc	r31, r31
    15e0:	ee 0f       	add	r30, r30
    15e2:	ff 1f       	adc	r31, r31
    15e4:	8e 0f       	add	r24, r30
    15e6:	9f 1f       	adc	r25, r31
    15e8:	fc 01       	movw	r30, r24
    15ea:	e6 50       	subi	r30, 0x06	; 6
    15ec:	f8 4f       	sbci	r31, 0xF8	; 248
    15ee:	80 81       	ld	r24, Z
    15f0:	88 23       	and	r24, r24
    15f2:	49 f3       	breq	.-46     	; 0x15c6 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    15f4:	e0 91 ed 07 	lds	r30, 0x07ED
    15f8:	f0 e0       	ldi	r31, 0x00	; 0
    15fa:	cf 01       	movw	r24, r30
    15fc:	88 0f       	add	r24, r24
    15fe:	99 1f       	adc	r25, r25
    1600:	88 0f       	add	r24, r24
    1602:	99 1f       	adc	r25, r25
    1604:	88 0f       	add	r24, r24
    1606:	99 1f       	adc	r25, r25
    1608:	e8 0f       	add	r30, r24
    160a:	f9 1f       	adc	r31, r25
    160c:	e6 50       	subi	r30, 0x06	; 6
    160e:	f8 4f       	sbci	r31, 0xF8	; 248
    1610:	a1 81       	ldd	r26, Z+1	; 0x01
    1612:	b2 81       	ldd	r27, Z+2	; 0x02
    1614:	12 96       	adiw	r26, 0x02	; 2
    1616:	0d 90       	ld	r0, X+
    1618:	bc 91       	ld	r27, X
    161a:	a0 2d       	mov	r26, r0
    161c:	b2 83       	std	Z+2, r27	; 0x02
    161e:	a1 83       	std	Z+1, r26	; 0x01
    1620:	cf 01       	movw	r24, r30
    1622:	03 96       	adiw	r24, 0x03	; 3
    1624:	a8 17       	cp	r26, r24
    1626:	b9 07       	cpc	r27, r25
    1628:	31 f4       	brne	.+12     	; 0x1636 <vTaskSwitchContext+0xa6>
    162a:	12 96       	adiw	r26, 0x02	; 2
    162c:	8d 91       	ld	r24, X+
    162e:	9c 91       	ld	r25, X
    1630:	13 97       	sbiw	r26, 0x03	; 3
    1632:	92 83       	std	Z+2, r25	; 0x02
    1634:	81 83       	std	Z+1, r24	; 0x01
    1636:	01 80       	ldd	r0, Z+1	; 0x01
    1638:	f2 81       	ldd	r31, Z+2	; 0x02
    163a:	e0 2d       	mov	r30, r0
    163c:	86 81       	ldd	r24, Z+6	; 0x06
    163e:	97 81       	ldd	r25, Z+7	; 0x07
    1640:	90 93 f7 07 	sts	0x07F7, r25
    1644:	80 93 f6 07 	sts	0x07F6, r24
    1648:	08 95       	ret

0000164a <memset>:
    164a:	dc 01       	movw	r26, r24
    164c:	01 c0       	rjmp	.+2      	; 0x1650 <memset+0x6>
    164e:	6d 93       	st	X+, r22
    1650:	41 50       	subi	r20, 0x01	; 1
    1652:	50 40       	sbci	r21, 0x00	; 0
    1654:	e0 f7       	brcc	.-8      	; 0x164e <memset+0x4>
    1656:	08 95       	ret

00001658 <strncpy>:
    1658:	fb 01       	movw	r30, r22
    165a:	dc 01       	movw	r26, r24
    165c:	41 50       	subi	r20, 0x01	; 1
    165e:	50 40       	sbci	r21, 0x00	; 0
    1660:	48 f0       	brcs	.+18     	; 0x1674 <strncpy+0x1c>
    1662:	01 90       	ld	r0, Z+
    1664:	0d 92       	st	X+, r0
    1666:	00 20       	and	r0, r0
    1668:	c9 f7       	brne	.-14     	; 0x165c <strncpy+0x4>
    166a:	01 c0       	rjmp	.+2      	; 0x166e <strncpy+0x16>
    166c:	1d 92       	st	X+, r1
    166e:	41 50       	subi	r20, 0x01	; 1
    1670:	50 40       	sbci	r21, 0x00	; 0
    1672:	e0 f7       	brcc	.-8      	; 0x166c <strncpy+0x14>
    1674:	08 95       	ret

00001676 <_exit>:
    1676:	f8 94       	cli

00001678 <__stop_program>:
    1678:	ff cf       	rjmp	.-2      	; 0x1678 <__stop_program>
